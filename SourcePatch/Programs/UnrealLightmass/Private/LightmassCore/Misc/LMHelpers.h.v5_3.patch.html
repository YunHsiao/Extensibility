<pre>// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
</pre><pre style="background:#ccffcc;">
// Extensibility+: Begin
#include "Modules/ModuleInterface.h"
namespace Lightmass
{
	class ILightmassPlugin : public IModuleInterface
	{
	public:
		virtual bool Import(class FLightmassImporter&amp; Importer, class FScene&amp; Scene) = 0;
	};
}
// Extensibility+: End

</pre><pre>namespace Lightmass
{

class FLightmassLog : public FOutputDevice
{
public:

	FLightmassLog();
	~FLightmassLog();

	// BEGIN FOutputDevice Interface 
	virtual void Serialize( const TCHAR* V, ELogVerbosity::Type Verbosity, const class FName&amp; Category ) override;
	virtual void Flush() override;
	// END FOutputDevice Interface

	/**
	 * Returns the filename of the log file.
	 */
	const TCHAR* GetLogFilename() const
	{
		return *Filename;
	}

	/**
	 * Singleton interface.
	 */
	static FLightmassLog* Get();

private:

	/** Handle to log file */
	FArchive*	File;

	/** Filename of the log file. */
	FString Filename;
};

/** Stores an SHA hash generated by FSHA1. */
class FSHAHash
{
public:
	uint8 Hash[20];

	inline FString ToString() const
	{
		return BytesToHex((const uint8*)Hash, sizeof(Hash));
	}

	friend bool operator==(const FSHAHash&amp; X, const FSHAHash&amp; Y)
	{
		return FMemory::Memcmp(&amp;X.Hash, &amp;Y.Hash, sizeof(X.Hash)) == 0;
	}

	friend bool operator!=(const FSHAHash&amp; X, const FSHAHash&amp; Y)
	{
		return FMemory::Memcmp(&amp;X.Hash, &amp;Y.Hash, sizeof(X.Hash)) != 0;
	}

	friend uint32 GetTypeHash(const FSHAHash&amp; H)
	{
		return FCrc::MemCrc32(H.Hash, sizeof(H.Hash));
	}
};
}
</pre>