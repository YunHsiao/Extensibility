<pre>// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "LMCore.h"
#include "LightmassSwarm.h"


namespace Lightmass
{


//@todo - need to pass to Serialization
class FLightmassImporter
{
protected:

	/**
	 * Finds existing or imports new object by Guid
	 *
	 * @param Key Key of object
	 * @param Version Version of object to load
	 * @param LMExecutableHash Hash of Lightmass executable to avoid stale cache content
	 * @param Extension Type of object to load (@todo UE5: This could be removed if Version could imply extension)
	 * @return The object that was loaded or found, or NULL if the Guid failed
	 */
	template &lt;class ObjType, class LookupMapType, class KeyType&gt;
	ObjType* ConditionalImportObjectWithKey(const KeyType&amp; Key, const int32 Version, const FSHAHash&amp; LMExecutableHash, const TCHAR* Extension, int32 ChannelFlags, LookupMapType&amp; LookupMap);

public:

	FLightmassImporter( class FLightmassSwarm* InSwarm );
	~FLightmassImporter();

	/**
	 * Imports a scene and all required dependent objects
	 *
	 * @param Scene Scene object to fill out
	 * @param SceneGuid Guid of the scene to load from a swarm channel
	 */
	bool ImportScene( class FScene&amp; Scene, const FGuid&amp; SceneGuid );
	/** Imports a buffer of raw data */
	bool Read( void* Data, int32 NumBytes );

	/** Imports one object */
	template &lt;class DataType&gt;
	bool ImportData( DataType* Data );

	/** Imports a TArray of simple elements in one bulk read. */
	template &lt;class ArrayType&gt;
	bool ImportArray( ArrayType&amp; Array, int32 Count );

	/** Imports a TArray of objects, while also adding them to the specified LookupMap. */
	template &lt;class ObjType, class LookupMapType&gt;
	bool ImportObjectArray( TArray&lt;ObjType&gt;&amp; Array, int32 Count, LookupMapType&amp; LookupMap );

	/** Imports an array of GUIDs and stores the corresponding pointers into a TArray */
	template &lt;class ArrayType, class LookupMapType&gt;
	bool ImportGuidArray( ArrayType&amp; Array, int32 Count, const LookupMapType&amp; LookupMap );

	/**
	 * Finds existing or imports new object by Guid
	 *
	 * @param Guid Guid of object
	 * @param Version Version of object to load
	 * @param Extension Type of object to load (@todo UE5: This could be removed if Version could imply extension)
	 * @return The object that was loaded or found, or NULL if the Guid failed
	 */
	template &lt;class ObjType, class LookupMapType&gt;
	ObjType* ConditionalImportObject(const FGuid&amp; Guid, const int32 Version, const TCHAR* Extension, int32 ChannelFlags, LookupMapType&amp; LookupMap)
	{
		return ConditionalImportObjectWithKey&lt;ObjType, LookupMapType, FGuid&gt;(Guid, Version, LightmassExecutableHash, Extension, ChannelFlags, LookupMap);
	}

	/**
	 * Finds existing or imports new object by Hash
	 *
	 * @param Hash Id of object
	 * @param Version Version of object to load
	 * @param Extension Type of object to load (@todo UE5: This could be removed if Version could imply extension)
	 * @return The object that was loaded or found, or NULL if the Guid failed
	 */
	template &lt;class ObjType, class LookupMapType&gt;
	ObjType* ConditionalImportObject(const FSHAHash&amp; Hash, const int32 Version, const TCHAR* Extension, int32 ChannelFlags, LookupMapType&amp; LookupMap)
	{
		return ConditionalImportObjectWithKey&lt;ObjType, LookupMapType, FSHAHash&gt;(Hash, Version, LightmassExecutableHash, Extension, ChannelFlags, LookupMap);
	}

	void SetLevelScale(float InScale) { LevelScale = InScale; }
	float GetLevelScale() const
	{
		checkf(LevelScale &gt; 0.0f, TEXT("LevelScale must be set by the scene before it can be used"));
		return LevelScale;
	}

	TMap&lt;FGuid,class FLight*&gt;&amp;										GetLights()					{ return Lights; }
	TMap&lt;FGuid,class FStaticMeshStaticLightingMesh*&gt;&amp;				GetStaticMeshInstances()	{ return StaticMeshInstances; }
	TMap&lt;FGuid,class FFluidSurfaceStaticLightingMesh*&gt;&amp;				GetFluidMeshInstances()		{ return FluidMeshInstances; }
	TMap&lt;FGuid,class FLandscapeStaticLightingMesh*&gt;&amp;				GetLandscapeMeshInstances()	{ return LandscapeMeshInstances; }
	TMap&lt;FGuid,class FStaticMeshStaticLightingTextureMapping*&gt;&amp;		GetTextureMappings()		{ return StaticMeshTextureMappings; }
	TMap&lt;FGuid,class FBSPSurfaceStaticLighting*&gt;&amp;					GetBSPMappings()			{ return BSPTextureMappings; }
	TMap&lt;FGuid,class FStaticMesh*&gt;&amp;									GetStaticMeshes()			{ return StaticMeshes; }
	TMap&lt;FGuid,class FFluidSurfaceStaticLightingTextureMapping*&gt;&amp;	GetFluidMappings()			{ return FluidMappings; }
	TMap&lt;FGuid,class FLandscapeStaticLightingTextureMapping*&gt;&amp;		GetLandscapeMappings()		{ return LandscapeMappings; }
	TMap&lt;FGuid,class FStaticLightingGlobalVolumeMapping*&gt;&amp;			GetVolumeMappings()			{ return VolumeMappings; }
	TMap&lt;FSHAHash,class FMaterial*&gt;&amp;								GetMaterials()				{ return Materials; }

</pre><pre style="background:#ccffcc;">	bool ImportCustomData(FScene&amp; Scene); // Extensibility+

</pre><pre>private:

	class FLightmassSwarm*	Swarm;
	FSHAHash LightmassExecutableHash;

	TMap&lt;FGuid,class FLight*&gt;										Lights;
	TMap&lt;FGuid,class FStaticMesh*&gt;									StaticMeshes;
	TMap&lt;FGuid,class FStaticMeshStaticLightingMesh*&gt;				StaticMeshInstances;
	TMap&lt;FGuid,class FFluidSurfaceStaticLightingMesh*&gt;				FluidMeshInstances;
	TMap&lt;FGuid,class FLandscapeStaticLightingMesh*&gt;					LandscapeMeshInstances;
	TMap&lt;FGuid,class FStaticMeshStaticLightingTextureMapping*&gt;		StaticMeshTextureMappings;
	TMap&lt;FGuid,class FBSPSurfaceStaticLighting*&gt;					BSPTextureMappings;	
	TMap&lt;FGuid,class FFluidSurfaceStaticLightingTextureMapping*&gt;	FluidMappings;
	TMap&lt;FGuid,class FLandscapeStaticLightingTextureMapping*&gt;		LandscapeMappings;
	TMap&lt;FGuid,class FStaticLightingGlobalVolumeMapping*&gt;			VolumeMappings;
	TMap&lt;FSHAHash,class FMaterial*&gt;									Materials;

	float LevelScale;
};


template &lt;typename DataType&gt;
FORCEINLINE bool FLightmassImporter::ImportData( DataType* Data )
{
	return Read( Data, sizeof(DataType) );
}


/** Imports a TArray of simple elements in one bulk read. */
template &lt;class ArrayType&gt;
bool FLightmassImporter::ImportArray( ArrayType&amp; Array, int32 Count )
{
	Array.Empty( Count );
	Array.AddUninitialized( Count );
	return Read( Array.GetData(), Count*sizeof(typename ArrayType::ElementType) );
}


/** Imports a TArray of objects, while also adding them to the specified LookupMap. */
template &lt;class ObjType, class LookupMapType&gt;
bool FLightmassImporter::ImportObjectArray( TArray&lt;ObjType&gt;&amp; Array, int32 Count, LookupMapType&amp; LookupMap )
{
	Array.Empty( Count );
	for ( int32 Index=0; Index &lt; Count; ++Index )
	{
		ObjType* Item = new(Array)ObjType;
		Item-&gt;Import( *this );
		LookupMap.Add( Item-&gt;Guid, Item );
	}
	return true;
}


/** Imports an array of GUIDs and stores the corresponding pointers into a TArray */
template &lt;class ArrayType, class LookupMapType&gt;
bool FLightmassImporter::ImportGuidArray( ArrayType&amp; Array, int32 Count, const LookupMapType&amp; LookupMap )
{
	bool bOk = true;
	Array.Empty( Count );
	for ( int32 Index=0; bOk &amp;&amp; Index &lt; Count; ++Index )
	{
		FGuid Guid;
		bOk = ImportData( &amp;Guid );
		Array.Add( LookupMap.FindRef( Guid ) );
	}
	return bOk;
}


/**
 * Finds existing or imports new object by Guid
 *
 * @param Key Key of object
 * @param Version Version of object to load
 * @param Extension Type of object to load (@todo UE5: This could be removed if Version could imply extension)
 * @return The object that was loaded or found, or NULL if the Guid failed
 */
template &lt;class ObjType, class LookupMapType, class KeyType&gt;
ObjType* FLightmassImporter::ConditionalImportObjectWithKey(const KeyType&amp; Key, const int32 Version, const FSHAHash&amp; LMExecutableHash, const TCHAR* Extension, int32 ChannelFlags, LookupMapType&amp; LookupMap)
{
	// look to see if it exists already
	ObjType* Obj = LookupMap.FindRef(Key);
	if (Obj == NULL)
	{
		// open a new channel and make it current
		if (Swarm-&gt;OpenChannel(*CreateChannelNameWithLMExecutableHash(Key, Version, LMExecutableHash, Extension), ChannelFlags, true) &gt;= 0)
		{
			Obj = new ObjType;

			// import the object from its own channel
			Obj-&gt;Import(*this);
		
			// close the object channel
			Swarm-&gt;CloseCurrentChannel();

			// cache this object so it can be found later by another call to this function
			LookupMap.Add(Key, Obj);
		}
	}

	return Obj;
}

}
</pre>