<pre>// Copyright Tencent Timi-J1&amp;F1 Studio, Inc. All Rights Reserved.

#include "ExtensibilityUnrealEd.h"

#include "Misc/EngineBuildSettings.h"
#include "StaticLightingSystem/StaticLightingPrivate.h"

#define LOCTEXT_NAMESPACE "Lightmass"

void FStaticLightingManager::LaunchCustomSystem(FStaticLightingSystem* CustomSystem)
{
	if (StaticLightingSystems.Num() == 0)
	{
		check(!ActiveStaticLightingSystem);

		bBuildReflectionCapturesOnFinish = false;
		StaticLightingSystems.Emplace(CustomSystem);
		ActiveStaticLightingSystem = StaticLightingSystems[0].Get();

		if (ActiveStaticLightingSystem-&gt;CheckLightmassExecutableVersion())
		{
			if (ActiveStaticLightingSystem-&gt;BeginLightmassProcess())
			{
				SendProgressNotification();
			}
			else
			{
				Get()-&gt;FailLightingBuild();
			}
		}
		else
		{
			if (FEngineBuildSettings::IsSourceDistribution())
			{
				Get()-&gt;FailLightingBuild(LOCTEXT("LightmassExecutableOutdatedMessage", "Unreal Lightmass executable is outdated. Recompile UnrealLightmass project with Development configuration in Visual Studio."));
			}
			else
			{
				// Lightmass should never be outdated in a launcher binary build.
				Get()-&gt;FailLightingBuild(LOCTEXT("LauncherBuildNeedsVerificationMessage", "Unreal Lightmass executable is damaged. Try verifying your engine installation in Epic Games Launcher."));
			}
		}
	}
	else
	{
		// Tell the user that they must close their current build first.
		FNotificationInfo Info( LOCTEXT("LightBuildInProgressWarning", "A lighting build is already in progress! Please cancel it before triggering a new build.") );
		Info.ExpireDuration = 5.0f;
		TSharedPtr&lt;SNotificationItem&gt; Notification = FSlateNotificationManager::Get().AddNotification(Info);
		if (Notification.IsValid())
		{
			Notification-&gt;SetCompletionState(SNotificationItem::CS_Fail);
		}
		delete CustomSystem;
	}
}

void FLightmassExporter::WriteCustomData(int32 Channel, bool bForceContentExport)
{
	</pre><pre style="background:#ccffcc;">// Extensibility+: Lightmass
	// Always use subclasses instead of modifying this function directly.
	</pre><pre>// Subclass implementations should always begin with:
	/*
	DependentPluginModules = TEXT("YourPlugin:Module1 YourPlugin:Module2");
	FLightmassExporter::WriteCustomData(Channel, bForceContentExport);
	*/

	int32 NameLength = DependentPluginModules.GetCharArray().Num();
	Swarm.WriteChannel(Channel, &amp;NameLength, sizeof(NameLength));
	Swarm.WriteChannel(Channel, *DependentPluginModules, NameLength * sizeof(TCHAR));
}

TSet&lt;FString&gt; FLightmassExporter::GetPluginBinaryDependencies(bool bIs64Bit) const
{
#if PLATFORM_WINDOWS
	static const FString BinaryPlatform32 = TEXT("Win32/");
	static const FString BinaryPlatform64 = TEXT("Win64/");
	static const FString BinaryExtension = TEXT("dll");
	const FString&amp; BinaryPlatform = bIs64Bit ? BinaryPlatform64 : BinaryPlatform32;
	const FString&amp; GeneralPlatform = BinaryPlatform;
#elif PLATFORM_MAC 
	static const FString BinaryPlatform = TEXT("Mac/");
	static const FString BinaryExtension = TEXT("dylib");
	const FString&amp; GeneralPlatform = BinaryPlatform;
#elif PLATFORM_LINUX 
	static const FString BinaryPlatform = TEXT("Linux/lib");
	static const FString GeneralPlatform = TEXT("Linux/");
	static const FString BinaryExtension = TEXT("so");
#else
#error "Unknown Lightmass platform"
#endif
	TSet&lt;FString&gt; Paths;

	TArray&lt;FString&gt; Modules;
	DependentPluginModules.ParseIntoArray(Modules, TEXT(" "));
	for (FString&amp; Pair : Modules)
	{
		FString Plugin, Module;
		check(Pair.Split(TEXT(":"), &amp;Plugin, &amp;Module));
		Paths.Emplace(FString::Printf(TEXT("Plugins/%s/Binaries/%sUnrealLightmass-%s.%s"), *Plugin, *BinaryPlatform, *Module, *BinaryExtension));
		// Do we need to manually merge this?
		Paths.Emplace(Pair = FString::Printf(TEXT("Plugins/%s/Binaries/%sUnrealLightmass.modules"), *Plugin, *GeneralPlatform));
	}
	return Paths;
}

#undef LOCTEXT_NAMESPACE
</pre>