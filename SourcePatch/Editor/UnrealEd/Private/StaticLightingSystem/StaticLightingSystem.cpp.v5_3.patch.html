<pre>// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	StaticLightingSystem.cpp: Bsp light mesh illumination builder code
=============================================================================*/

#include "CoreMinimal.h"
#include "Misc/MessageDialog.h"
#include "HAL/FileManager.h"
#include "Misc/Paths.h"
#include "Misc/Guid.h"
#include "Misc/ConfigCacheIni.h"
#include "Misc/ConfigContext.h"
#include "HAL/IConsoleManager.h"
#include "Misc/ScopedSlowTask.h"
#include "Misc/App.h"
#include "Modules/ModuleManager.h"
#include "UObject/ObjectMacros.h"
#include "UObject/GarbageCollection.h"
#include "Layout/Visibility.h"
#include "Framework/Application/SlateApplication.h"
#include "Engine/EngineTypes.h"
#include "GameFramework/Actor.h"
#include "Components/PrimitiveComponent.h"
#include "Components/StaticMeshComponent.h"
#include "Components/LightComponentBase.h"
#include "Components/ReflectionCaptureComponent.h"
#include "AI/NavigationSystemBase.h"
#include "Engine/MapBuildDataRegistry.h"
#include "Components/LightComponent.h"
#include "Model.h"
#include "Engine/Brush.h"
#include "Misc/PackageName.h"
#include "Editor/EditorEngine.h"
#include "Settings/EditorExperimentalSettings.h"
#include "Settings/LevelEditorMiscSettings.h"
#include "Engine/Texture2D.h"
#include "Misc/FeedbackContext.h"
#include "UObject/UObjectHash.h"
#include "UObject/UObjectIterator.h"
#include "GameFramework/WorldSettings.h"
#include "Engine/GeneratedMeshAreaLight.h"
#include "Components/SkyLightComponent.h"
#include "Components/SkyAtmosphereComponent.h"
#include "Components/ModelComponent.h"
#include "Engine/LightMapTexture2D.h"
#include "Editor.h"
#include "Engine/Selection.h"
#include "EditorModeManager.h"
#include "EditorModes.h"
#include "Dialogs/Dialogs.h"

FSwarmDebugOptions GSwarmDebugOptions;

#include "Lightmass/LightmassCharacterIndirectDetailVolume.h"
#include "Lightmass/VolumetricLightmapDensityVolume.h"
#include "StaticLighting.h"
#include "StaticLightingSystem/StaticLightingPrivate.h"
#include "ModelLight.h"
#include "Engine/LevelStreaming.h"
#include "LevelUtils.h"
#include "EngineModule.h"
#include "LightMap.h"
#include "ShadowMap.h"
#include "EditorBuildUtils.h"
#include "ComponentRecreateRenderStateContext.h"
#include "Engine/LODActor.h"

DEFINE_LOG_CATEGORY(LogStaticLightingSystem);

#include "EngineGlobals.h"


#include "Lightmass/LightmassImportanceVolume.h"
#include "Components/LightmassPortalComponent.h"
#include "Lightmass/Lightmass.h"
#include "StatsViewerModule.h"
#include "Logging/TokenizedMessage.h"
#include "Logging/MessageLog.h"
#include "Framework/Notifications/NotificationManager.h"
#include "Widgets/Notifications/SNotificationList.h"
#include "Misc/UObjectToken.h"
#include "Subsystems/AssetEditorSubsystem.h"
#include "Rendering/StaticLightingSystemInterface.h"
#include "BuildSettings.h"
#include "Misc/EngineBuildSettings.h"
#include "TargetReceipt.h"

#define LOCTEXT_NAMESPACE "StaticLightingSystem"

/** The number of hardware threads to not use for building static lighting. */
#define NUM_STATIC_LIGHTING_UNUSED_THREADS 0

bool GbLogAddingMappings = false;

/** Counts the number of lightmap textures generated each lighting build. */
extern ENGINE_API int32 GLightmapCounter;
/** Whether to compress lightmaps. Reloaded from ini each lighting build. */
extern ENGINE_API bool GCompressLightmaps;

/** Whether to allow lighting builds to generate streaming lightmaps. */
extern ENGINE_API bool GAllowStreamingLightmaps;

// NOTE: We're only counting the top-level mip-map for the following variables.
/** Total number of texels allocated for all lightmap textures. */
extern ENGINE_API uint64 GNumLightmapTotalTexels;
/** Total number of texels used if the texture was non-power-of-two. */
extern ENGINE_API uint64 GNumLightmapTotalTexelsNonPow2;
/** Number of lightmap textures generated. */
extern ENGINE_API int32 GNumLightmapTextures;
/** Total number of mapped texels. */
extern ENGINE_API uint64 GNumLightmapMappedTexels;
/** Total number of unmapped texels. */
extern ENGINE_API uint64 GNumLightmapUnmappedTexels;
/** Whether to allow cropping of unmapped borders in lightmaps and shadowmaps. Controlled by BaseEngine.ini setting. */
extern ENGINE_API bool GAllowLightmapCropping;
/** Total lightmap texture memory size (in bytes), including GLightmapTotalStreamingSize. */
extern ENGINE_API uint64 GLightmapTotalSize;
/** Total memory size for streaming lightmaps (in bytes). */
extern ENGINE_API uint64 GLightmapTotalStreamingSize;
/** Largest boundingsphere radius to use when packing lightmaps into a texture atlas. */
extern ENGINE_API float GMaxLightmapRadius;

/** Total number of texels allocated for all shadowmap textures. */
extern ENGINE_API uint64 GNumShadowmapTotalTexels;
/** Number of shadowmap textures generated. */
extern ENGINE_API int32 GNumShadowmapTextures;
/** Total number of mapped texels. */
extern ENGINE_API uint64 GNumShadowmapMappedTexels;
/** Total number of unmapped texels. */
extern ENGINE_API uint64 GNumShadowmapUnmappedTexels;
/** Total shadowmap texture memory size (in bytes), including GShadowmapTotalStreamingSize. */
extern ENGINE_API uint64 GShadowmapTotalSize;
/** Total texture memory size for streaming shadowmaps. */
extern ENGINE_API uint64 GShadowmapTotalStreamingSize;

/** If non-zero, purge old lightmap data when rebuilding lighting. */
int32 GPurgeOldLightmaps=1;
static FAutoConsoleVariableRef CVarPurgeOldLightmaps(
	TEXT("PurgeOldLightmaps"),
	GPurgeOldLightmaps,
	TEXT("If non-zero, purge old lightmap data when rebuilding lighting.")
	);


int32 GMultithreadedLightmapEncode = 1;
static FAutoConsoleVariableRef CVarMultithreadedLightmapEncode(TEXT("r.MultithreadedLightmapEncode"), GMultithreadedLightmapEncode, TEXT("Lightmap encoding after rebuild lightmaps is done multithreaded."));
int32 GMultithreadedShadowmapEncode = 1;
static FAutoConsoleVariableRef CVarMultithreadedShadowmapEncode(TEXT("r.MultithreadedShadowmapEncode"), GMultithreadedShadowmapEncode, TEXT("Shadowmap encoding after rebuild lightmaps is done multithreaded."));




TSharedPtr&lt;FStaticLightingManager&gt; FStaticLightingManager::StaticLightingManager;

TSharedPtr&lt;FStaticLightingManager&gt; FStaticLightingManager::Get()
{
	if (!StaticLightingManager.IsValid())
	{
		StaticLightingManager = MakeShareable(new FStaticLightingManager);
	}
	return StaticLightingManager;
}

void FStaticLightingManager::ProcessLightingData()
{
	auto StaticLightingSystem = FStaticLightingManager::Get()-&gt;ActiveStaticLightingSystem;

	check(StaticLightingSystem);

	FNavigationLockContext NavUpdateLock(StaticLightingSystem-&gt;GetWorld(), ENavigationLockReason::LightingUpdate);

	bool bSuccessful = StaticLightingSystem-&gt;FinishLightmassProcess();

	FEditorDelegates::OnLightingBuildKept.Broadcast();

	if (!bSuccessful)
	{
		FStaticLightingManager::Get()-&gt;FailLightingBuild();
	}

	FStaticLightingManager::Get()-&gt;ClearCurrentNotification();
}

void FStaticLightingManager::CancelLightingBuild()
{
	if (FStaticLightingManager::Get()-&gt;ActiveStaticLightingSystem-&gt;IsAsyncBuilding())
	{
		GEditor-&gt;SetMapBuildCancelled( true );
		FStaticLightingManager::Get()-&gt;ClearCurrentNotification();
		FEditorDelegates::OnLightingBuildFailed.Broadcast();
	}
	else
	{
		FStaticLightingManager::Get()-&gt;FailLightingBuild();
	}
}

void FStaticLightingManager::SendProgressNotification()
{
	// Start the lightmass 'progress' notification
	FNotificationInfo Info( LOCTEXT("LightBuildMessage", "Building lighting") );
	Info.bFireAndForget = false;
	Info.ButtonDetails.Add(FNotificationButtonInfo(
		LOCTEXT("LightBuildCancel","Cancel"),
		LOCTEXT("LightBuildCancelToolTip","Cancels the lighting build in progress."),
		FSimpleDelegate::CreateStatic(&amp;FStaticLightingManager::CancelLightingBuild)));

	LightBuildNotification = FSlateNotificationManager::Get().AddNotification(Info);
	if (LightBuildNotification.IsValid())
	{
		LightBuildNotification.Pin()-&gt;SetCompletionState(SNotificationItem::CS_Pending);
	}
}

void FStaticLightingManager::ClearCurrentNotification()
{
	if ( LightBuildNotification.IsValid() )
	{
		LightBuildNotification.Pin()-&gt;SetCompletionState(SNotificationItem::CS_None);
		LightBuildNotification.Pin()-&gt;ExpireAndFadeout();
		LightBuildNotification.Reset();
	}
}

void FStaticLightingManager::SetNotificationText( FText Text )
{
	if ( LightBuildNotification.IsValid() )
	{
		LightBuildNotification.Pin()-&gt;SetText( Text );
	}
}

void FStaticLightingManager::ImportRequested()
{
	if (FStaticLightingManager::Get()-&gt;ActiveStaticLightingSystem)
	{
		FStaticLightingManager::Get()-&gt;ActiveStaticLightingSystem-&gt;CurrentBuildStage = FStaticLightingSystem::ImportRequested;
	}
}

void FStaticLightingManager::DiscardRequested()
{
	if (FStaticLightingManager::Get()-&gt;ActiveStaticLightingSystem)
	{
		FStaticLightingManager::Get()-&gt;ClearCurrentNotification();
		FStaticLightingManager::Get()-&gt;ActiveStaticLightingSystem-&gt;CurrentBuildStage = FStaticLightingSystem::Finished;
	}
}

void FStaticLightingManager::SendBuildDoneNotification( bool AutoApplyFailed )
{
	FText CompletedText = LOCTEXT("LightBuildDoneMessage", "Lighting build completed");

	if (ActiveStaticLightingSystem != StaticLightingSystems.Last().Get() &amp;&amp; ActiveStaticLightingSystem-&gt;LightingScenario)
	{
		FString PackageName = FPackageName::GetShortName(ActiveStaticLightingSystem-&gt;LightingScenario-&gt;GetOutermost()-&gt;GetName());
		CompletedText = FText::Format(LOCTEXT("LightScenarioBuildDoneMessage", "{0} Lighting Scenario completed"), FText::FromString(PackageName));
	}

	FNotificationInfo Info(CompletedText);
	Info.bFireAndForget = false;
	Info.bUseThrobber = false;

	FNotificationButtonInfo ApplyNow = FNotificationButtonInfo(
		LOCTEXT( "LightBuildKeep", "Apply Now" ),
		LOCTEXT( "LightBuildKeepToolTip", "Keeps and applies built lighting data." ),
		FSimpleDelegate::CreateStatic( &amp;FStaticLightingManager::ImportRequested ) );
	ApplyNow.VisibilityOnSuccess = EVisibility::Collapsed;

	FNotificationButtonInfo Discard = FNotificationButtonInfo(
		LOCTEXT( "LightBuildDiscard", "Discard" ),
		LOCTEXT( "LightBuildDiscardToolTip", "Ignores the built lighting data generated." ),
		FSimpleDelegate::CreateStatic( &amp;FStaticLightingManager::DiscardRequested ) );
	Discard.VisibilityOnSuccess = EVisibility::Collapsed;

	Info.ButtonDetails.Add( ApplyNow );
	Info.ButtonDetails.Add( Discard );

	FEditorDelegates::OnLightingBuildSucceeded.Broadcast();

	LightBuildNotification = FSlateNotificationManager::Get().AddNotification( Info );
	if ( LightBuildNotification.IsValid() )
	{
		LightBuildNotification.Pin()-&gt;SetCompletionState( AutoApplyFailed ? SNotificationItem::CS_Pending : SNotificationItem::CS_Success );
	}
}

void FStaticLightingManager::CreateStaticLightingSystem(const FLightingBuildOptions&amp; Options)
{
	if (StaticLightingSystems.Num() == 0)
	{
		check(!ActiveStaticLightingSystem);

		bBuildReflectionCapturesOnFinish = !Options.bOnlyBuildVisibility;

		UWorld* World = GWorld;
		
		for (ULevel* Level : World-&gt;GetLevels())
		{
			if (Level-&gt;bIsLightingScenario &amp;&amp; Level-&gt;bIsVisible)
			{
				StaticLightingSystems.Emplace(new FStaticLightingSystem(Options, World, Level));
			}
		}

		if (StaticLightingSystems.Num() == 0)
		{
			StaticLightingSystems.Emplace(new FStaticLightingSystem(Options, World, nullptr));
		}

		ActiveStaticLightingSystem = StaticLightingSystems[0].Get();

		if (ActiveStaticLightingSystem-&gt;CheckLightmassExecutableVersion())
		{
			if (ActiveStaticLightingSystem-&gt;BeginLightmassProcess())
			{
				SendProgressNotification();
			}
			else
			{
				FStaticLightingManager::Get()-&gt;FailLightingBuild();
			}
		}
		else
		{
			if (FEngineBuildSettings::IsSourceDistribution())
			{
				FStaticLightingManager::Get()-&gt;FailLightingBuild(LOCTEXT("LightmassExecutableOutdatedMessage", "Unreal Lightmass executable is outdated. Recompile UnrealLightmass project with Development configuration in Visual Studio."));
			}
			else
			{
				// Lightmass should never be outdated in a launcher binary build.
				FStaticLightingManager::Get()-&gt;FailLightingBuild(LOCTEXT("LauncherBuildNeedsVerificationMessage", "Unreal Lightmass executable is damaged. Try verifying your engine installation in Epic Games Launcher."));
			}
		}
	}
	else
	{
		// Tell the user that they must close their current build first.
		FNotificationInfo Info( LOCTEXT("LightBuildInProgressWarning", "A lighting build is already in progress! Please cancel it before triggering a new build.") );
		Info.ExpireDuration = 5.0f;
		TSharedPtr&lt;SNotificationItem&gt; Notification = FSlateNotificationManager::Get().AddNotification(Info);
		if (Notification.IsValid())
		{
			Notification-&gt;SetCompletionState(SNotificationItem::CS_Fail);
		}

		FEditorDelegates::OnLightingBuildFailed.Broadcast();
	}
}

void FStaticLightingManager::UpdateBuildLighting()
{
	if (ActiveStaticLightingSystem != NULL)
	{
		// Note: UpdateLightingBuild can change ActiveStaticLightingSystem
		ActiveStaticLightingSystem-&gt;UpdateLightingBuild();

		if (ActiveStaticLightingSystem &amp;&amp; ActiveStaticLightingSystem-&gt;CurrentBuildStage == FStaticLightingSystem::Finished)
		{
			ActiveStaticLightingSystem = nullptr;
			StaticLightingSystems.RemoveAt(0);

			if (StaticLightingSystems.Num() &gt; 0)
			{
				ActiveStaticLightingSystem = StaticLightingSystems[0].Get();

				bool bSuccess = ActiveStaticLightingSystem-&gt;BeginLightmassProcess();

				if (bSuccess)
				{
					SendProgressNotification();
				}
				else
				{
					// BeginLightmassProcess returns false if there are errors or no precomputed lighting is allowed. Handle both cases.
					static const auto AllowStaticLightingVar = IConsoleManager::Get().FindTConsoleVariableDataInt(TEXT("r.AllowStaticLighting"));
					const bool bAllowStaticLighting = (!AllowStaticLightingVar || AllowStaticLightingVar-&gt;GetValueOnGameThread() != 0);
					</pre><pre style="background:#ccffcc;">// </pre><pre>const bool bForceNoPrecomputedLighting = GWorld-&gt;GetWorldSettings()-&gt;bForceNoPrecomputedLighting || !bAllowStaticLighting;</pre><pre style="background:#ccffcc;"> // Extensibility+-
					const bool bForceNoPrecomputedLighting = !ActiveStaticLightingSystem-&gt;bForceAllowStaticLighting &amp;&amp; (GWorld-&gt;GetWorldSettings()-&gt;bForceNoPrecomputedLighting || !bAllowStaticLighting); // Extensibility+
</pre><pre>
					if (bForceNoPrecomputedLighting)
					{
						DestroyStaticLightingSystems();
					}
					else
					{
						FStaticLightingManager::Get()-&gt;FailLightingBuild();
					}
				}
			}
		}

		if (!ActiveStaticLightingSystem)
		{
			FinishLightingBuild();
		}
	}
}

void FStaticLightingManager::FailLightingBuild( FText ErrorText)
{
	static const auto AllowStaticLightingVar = IConsoleManager::Get().FindTConsoleVariableDataInt(TEXT("r.AllowStaticLighting"));
	const bool bAllowStaticLighting = (!AllowStaticLightingVar || AllowStaticLightingVar-&gt;GetValueOnGameThread() != 0);
	</pre><pre style="background:#ccffcc;">// </pre><pre>const bool bForceNoPrecomputedLighting = GWorld-&gt;GetWorldSettings()-&gt;bForceNoPrecomputedLighting || !bAllowStaticLighting;</pre><pre style="background:#ccffcc;"> // Extensibility+-
	const bool bForceNoPrecomputedLighting = !ActiveStaticLightingSystem-&gt;bForceAllowStaticLighting &amp;&amp; (GWorld-&gt;GetWorldSettings()-&gt;bForceNoPrecomputedLighting || !bAllowStaticLighting); // Extensibility+
</pre><pre>
	FStaticLightingManager::Get()-&gt;ClearCurrentNotification();
	
	if (!bForceNoPrecomputedLighting)
	{
		if (GEditor-&gt;GetMapBuildCancelled())
		{
			ErrorText = LOCTEXT("LightBuildCanceledMessage", "Lighting build canceled.");
		}
		else
		{
			// Override failure message if one provided
			if (ErrorText.IsEmpty())
			{
				ErrorText = LOCTEXT("LightBuildFailedMessage", "Lighting build failed.");
			}
		}

		FNotificationInfo Info( ErrorText );
		Info.ExpireDuration = 4.f;
	
		FEditorDelegates::OnLightingBuildFailed.Broadcast();

		LightBuildNotification = FSlateNotificationManager::Get().AddNotification(Info);
		if (LightBuildNotification.IsValid())
		{
			LightBuildNotification.Pin()-&gt;SetCompletionState(SNotificationItem::CS_Fail);
		}

		UE_LOG(LogStaticLightingSystem, Warning, TEXT("Failed to build lighting!!! %s"),*ErrorText.ToString());

		FMessageLog("LightingResults").Open();
	}

	DestroyStaticLightingSystems();
}

void FStaticLightingManager::FinishLightingBuild()
{
	UWorld* World = GWorld;
</pre><pre style="background:#ffcccc;">	GetRendererModule().UpdateMapNeedsLightingFullyRebuiltState(World);</pre><pre style="background:#ccffcc;">
	// Extensibility+: Begin
	if (!IsRunningCommandlet() || IsAllowCommandletRendering())
	{
		GetRendererModule().UpdateMapNeedsLightingFullyRebuiltState(World);
	}
	// Extensibility+: End

	// GetRendererModule().UpdateMapNeedsLightingFullyRebuiltState(World); // Extensibility+-
</pre><pre>	GEngine-&gt;DeferredCommands.AddUnique(TEXT("MAP CHECK NOTIFYRESULTS"));

	if (World-&gt;Scene)
	{
		// Everything should be built at this point, dump unbuilt interactions for debugging
		World-&gt;Scene-&gt;DumpUnbuiltLightInteractions(*GLog);
	}

	if (bBuildReflectionCapturesOnFinish)
	{
		GEditor-&gt;BuildReflectionCaptures(World);
	}
}

void FStaticLightingManager::DestroyStaticLightingSystems()
{
	ActiveStaticLightingSystem = NULL;
	StaticLightingSystems.Empty();
}

bool FStaticLightingManager::IsLightingBuildCurrentlyRunning() const
{
	return ActiveStaticLightingSystem != NULL;
}

bool FStaticLightingManager::IsLightingBuildCurrentlyExporting() const
{
	return ActiveStaticLightingSystem != NULL &amp;&amp; ActiveStaticLightingSystem-&gt;IsAmortizedExporting();
}

FStaticLightingSystem::FStaticLightingSystem(const FLightingBuildOptions&amp; InOptions, UWorld* InWorld, ULevel* InLightingScenario)
	: Options(InOptions)
	, bBuildCanceled(false)
	, DeterministicIndex(0)
	, NextVisibilityId(0)
	, CurrentBuildStage(FStaticLightingSystem::NotRunning)
	, World(InWorld)
	, LightingScenario(InLightingScenario)
	, LightmassProcessor(NULL)
{
}

FStaticLightingSystem::~FStaticLightingSystem()
{
	if (LightmassProcessor)
	{
		delete LightmassProcessor;
	}
}

bool FStaticLightingSystem::CheckLightmassExecutableVersion()
{
	FTargetReceipt LightmassReceipt;
	
	if (!LightmassReceipt.Read(FTargetReceipt::GetDefaultPath(*FPaths::EngineDir(), TEXT("UnrealLightmass"), FPlatformProcess::GetBinariesSubdirectory(), EBuildConfiguration::Development, nullptr)))
	{
		return false;
	}

	return BuildSettings::GetCurrentChangelist() == LightmassReceipt.Version.Changelist;
}

bool FStaticLightingSystem::BeginLightmassProcess()
{
	StartTime = FPlatformTime::Seconds();
	
	CurrentBuildStage = FStaticLightingSystem::Startup;

	bool bRebuildDirtyGeometryForLighting = true;
	bool bForceNoPrecomputedLighting = false;

	GDebugStaticLightingInfo = FDebugLightingOutput();

	{
		FLightmassStatistics::FScopedGather StartupStatScope(LightmassStatistics.StartupTime);

		// Flip the results page
		FFormatNamedArguments Arguments;
		Arguments.Add(TEXT("TimeStamp"), FText::AsDateTime(FDateTime::Now()));
		FText LightingResultsPageName(FText::Format(LOCTEXT("LightingResultsPageName", "Lighting Build - {TimeStamp}"), Arguments));
		FMessageLog("LightingResults").NewPage(LightingResultsPageName);


		FStatsViewerModule&amp; StatsViewerModule = FModuleManager::Get().LoadModuleChecked&lt;FStatsViewerModule&gt;(TEXT("StatsViewer"));
		StatsViewerModule.GetPage(EStatsPage::LightingBuildInfo)-&gt;Clear();

		GLightmapCounter = 0;
		GNumLightmapTotalTexels = 0;
		GNumLightmapTotalTexelsNonPow2 = 0;
		GNumLightmapTextures = 0;
		GNumLightmapMappedTexels = 0;
		GNumLightmapUnmappedTexels = 0;
		GLightmapTotalSize = 0;
		GLightmapTotalStreamingSize = 0;

		GNumShadowmapTotalTexels = 0;
		GNumShadowmapTextures = 0;
		GNumShadowmapMappedTexels = 0;
		GNumShadowmapUnmappedTexels = 0;
		GShadowmapTotalSize = 0;
		GShadowmapTotalStreamingSize = 0;

		TSet&lt;UPackage*&gt; PackagesToDirty;

		for( TObjectIterator&lt;UPrimitiveComponent&gt; It ; It ; ++It )
		{
			UPrimitiveComponent* Component = *It;
			if (Component-&gt;VisibilityId != INDEX_NONE)
			{
				Component-&gt;VisibilityId = INDEX_NONE;
				PackagesToDirty.Add(Component-&gt;GetPackage());
			}
		}

		{
			TMap&lt;FGuid, ULevel*&gt; LevelGuids;

			for (int32 LevelIndex = 0; LevelIndex &lt; World-&gt;GetNumLevels(); LevelIndex++)
			{
				ULevel* Level = World-&gt;GetLevel(LevelIndex);

				if (ShouldOperateOnLevel(Level) &amp;&amp; Options.ShouldBuildLightingForLevel(Level))
				{
					if (LevelGuids.Contains(Level-&gt;LevelBuildDataId))
					{
						FMessageLog("LightingResults").Warning()
							-&gt;AddToken(FUObjectToken::Create(LevelGuids[Level-&gt;LevelBuildDataId]-&gt;GetOuter()))
							-&gt;AddToken(FTextToken::Create(LOCTEXT("LightmassError_DuplicatedLevelGuids1", "has the same level built data GUID as")))
							-&gt;AddToken(FUObjectToken::Create(Level-&gt;GetOuter()))
							-&gt;AddToken(FTextToken::Create(LOCTEXT("LightmassError_DuplicatedLevelGuids2", ". A new GUID is assigned to the later one. All previously built lighting is invalidated and the level needs to be resaved.")));

						Level-&gt;LevelBuildDataId = FGuid::NewGuid();
						PackagesToDirty.Add(Level-&gt;GetPackage());
					}

					LevelGuids.Add(Level-&gt;LevelBuildDataId, Level);
				}
			}
		}

		// Mark package(s) as dirty
		for (UPackage* Package : PackagesToDirty)
		{
			Package-&gt;MarkPackageDirty();
		}

		FString SkippedLevels;
		for ( int32 LevelIndex=0; LevelIndex &lt; World-&gt;GetNumLevels(); LevelIndex++ )
		{
			ULevel* Level = World-&gt;GetLevel(LevelIndex);

			if (ShouldOperateOnLevel(Level))
			{
				Level-&gt;LightmapTotalSize = 0.0f;
				Level-&gt;ShadowmapTotalSize = 0.0f;
				ULevelStreaming* LevelStreaming = NULL;
				if ( World-&gt;PersistentLevel != Level )
				{
					LevelStreaming = FLevelUtils::FindStreamingLevel( Level );
				}
				if (!Options.ShouldBuildLightingForLevel(Level))
				{
					if (SkippedLevels.Len() &gt; 0)
					{
						SkippedLevels += FString(TEXT(", "));
					}
					SkippedLevels += Level-&gt;GetName();
					GatherBuildDataResourcesToKeep(Level);
				}
			}
			else if (Level &amp;&amp; !Level-&gt;bIsLightingScenario &amp;&amp; !Level-&gt;bIsVisible)
			{
				GatherBuildDataResourcesToKeep(Level);
			}
		}

		for (ULevelStreaming* CurStreamingLevel : World-&gt;GetStreamingLevels())
		{
			if (CurStreamingLevel &amp;&amp; CurStreamingLevel-&gt;GetLoadedLevel() &amp;&amp; !CurStreamingLevel-&gt;GetShouldBeVisibleInEditor())
			{
				if (SkippedLevels.Len() &gt; 0)
				{
					SkippedLevels += FString(TEXT(", ")) + CurStreamingLevel-&gt;GetWorldAssetPackageName();
				}
				else
				{
					SkippedLevels += CurStreamingLevel-&gt;GetWorldAssetPackageName();
				}
			}
		}

		if (SkippedLevels.Len() &gt; 0 &amp;&amp; !IsRunningCommandlet())
		{
			// Warn when some levels are not visible and therefore will not be built, because that indicates that only a partial build will be done,
			// Lighting will still be unbuilt for some areas when playing through the level.
			const FText SkippedLevelsWarning = FText::Format( LOCTEXT("SkippedLevels", "The following levels will not have the lighting rebuilt because of your selected lighting build options: {0}"), FText::FromString( SkippedLevels ) );
			FSuppressableWarningDialog::FSetupInfo Info( SkippedLevelsWarning, LOCTEXT("SkippedLevelsDialogTitle", "Rebuild Lighting - Warning" ), "WarnOnHiddenLevelsBeforeRebuild" );
			Info.ConfirmText = LOCTEXT("SkippedWarningConfirm", "Build");

			FSuppressableWarningDialog WarnAboutSkippedLevels( Info );
			WarnAboutSkippedLevels.ShowModal();
		}
	
		static const auto AllowStaticLightingVar = IConsoleManager::Get().FindTConsoleVariableDataInt(TEXT("r.AllowStaticLighting"));
		const bool bAllowStaticLighting = (!AllowStaticLightingVar || AllowStaticLightingVar-&gt;GetValueOnGameThread() != 0);
		</pre><pre style="background:#ccffcc;">// </pre><pre>bForceNoPrecomputedLighting = World-&gt;GetWorldSettings()-&gt;bForceNoPrecomputedLighting || !bAllowStaticLighting;</pre><pre style="background:#ccffcc;"> // Extensibility+-
		bForceNoPrecomputedLighting = !bForceAllowStaticLighting &amp;&amp; (World-&gt;GetWorldSettings()-&gt;bForceNoPrecomputedLighting || !bAllowStaticLighting); // Extensibility+
</pre><pre>		GConfig-&gt;GetFloat( TEXT("TextureStreaming"), TEXT("MaxLightmapRadius"), GMaxLightmapRadius, GEngineIni );
		GConfig-&gt;GetBool( TEXT("TextureStreaming"), TEXT("AllowStreamingLightmaps"), GAllowStreamingLightmaps, GEngineIni );
		
		if (!bForceNoPrecomputedLighting)
		{
			// Begin the static lighting progress bar.
			GWarn-&gt;BeginSlowTask( LOCTEXT("BeginBuildingStaticLightingTaskStatus", "Building lighting"), false );
		}
		else
		{
			UE_LOG(LogStaticLightingSystem, Warning, TEXT("WorldSettings.bForceNoPrecomputedLighting is true, Skipping Lighting Build!"));
		}
		
		FConfigContext::ForceReloadIntoGConfig().Load(TEXT("Lightmass"), GLightmassIni);

		verify(GConfig-&gt;GetBool(TEXT("DevOptions.StaticLighting"), TEXT("bUseBilinearFilterLightmaps"), GUseBilinearLightmaps, GLightmassIni));
		verify(GConfig-&gt;GetBool(TEXT("DevOptions.StaticLighting"), TEXT("bAllowCropping"), GAllowLightmapCropping, GLightmassIni));
		verify(GConfig-&gt;GetBool(TEXT("DevOptions.StaticLighting"), TEXT("bRebuildDirtyGeometryForLighting"), bRebuildDirtyGeometryForLighting, GLightmassIni));
		verify(GConfig-&gt;GetBool(TEXT("DevOptions.StaticLighting"), TEXT("bCompressLightmaps"), GCompressLightmaps, GLightmassIni));

		GCompressLightmaps = GCompressLightmaps &amp;&amp; World-&gt;GetWorldSettings()-&gt;LightmassSettings.bCompressLightmaps;

		GAllowLightmapPadding = true;
		FMemory::Memzero(&amp;LightingMeshBounds, sizeof(FBox));
		FMemory::Memzero(&amp;AutomaticImportanceVolumeBounds, sizeof(FBox));

		GLightingBuildQuality = Options.QualityLevel;
	
	}

	{
		FLightmassStatistics::FScopedGather CollectStatScope(LightmassStatistics.CollectTime);

		// Prepare lights for rebuild.
		{
			FLightmassStatistics::FScopedGather PrepareStatScope(LightmassStatistics.PrepareLightsTime);

			if (!Options.bOnlyBuildVisibility)
			{
				// Delete all AGeneratedMeshAreaLight's, since new ones will be created after the build with updated properties.
				USelection* EditorSelection = GEditor-&gt;GetSelectedActors();
				for(TObjectIterator&lt;AGeneratedMeshAreaLight&gt; LightIt;LightIt;++LightIt)
				{
					if (ShouldOperateOnLevel((*LightIt)-&gt;GetLevel()))
					{
					if (EditorSelection)
					{
						EditorSelection-&gt;Deselect(*LightIt);
					}
					(*LightIt)-&gt;GetWorld()-&gt;DestroyActor(*LightIt);
				}
				}

				for (TObjectIterator&lt;ULightComponentBase&gt; LightIt(RF_ClassDefaultObject, /** bIncludeDerivedClasses */ true, /** InternalExcludeFlags */ EInternalObjectFlags::Garbage); LightIt; ++LightIt)
				{
					ULightComponentBase* const Light = *LightIt;
					const bool bLightIsInWorld = IsValid(Light-&gt;GetOwner()) 
						&amp;&amp; World-&gt;ContainsActor(Light-&gt;GetOwner());

					if (bLightIsInWorld &amp;&amp; ShouldOperateOnLevel(Light-&gt;GetOwner()-&gt;GetLevel()))
					{
						if (Light-&gt;bAffectsWorld 
							&amp;&amp; Light-&gt;IsRegistered()
							&amp;&amp; (Light-&gt;HasStaticShadowing() || Light-&gt;HasStaticLighting()))
						{
							// Make sure the light GUIDs are up-to-date.
							Light-&gt;ValidateLightGUIDs();

							// Add the light to the system's list of lights in the world.
							Lights.Add(Light);
						}
					}
				}
			}
		}

		{
			FLightmassStatistics::FScopedGather GatherStatScope(LightmassStatistics.GatherLightingInfoTime);

			if (IsTexelDebuggingEnabled())
			{
				// Clear reference to the selected lightmap
				GCurrentSelectedLightmapSample.Lightmap = NULL;
			}
			
			GatherStaticLightingInfo(bRebuildDirtyGeometryForLighting, bForceNoPrecomputedLighting);
		}

		// Sort the mappings - and tag meshes if doing deterministic mapping
		if (GLightmassDebugOptions.bSortMappings)
		{
			struct FCompareNumTexels
			{
				FORCEINLINE bool operator()( const FStaticLightingMappingSortHelper&amp; A, const FStaticLightingMappingSortHelper&amp; B ) const
				{
					return B.NumTexels &lt; A.NumTexels;
				}
			};
			UnSortedMappings.Sort( FCompareNumTexels() );
		
			for (int32 SortIndex = 0; SortIndex &lt; UnSortedMappings.Num(); SortIndex++)
			{
				FStaticLightingMapping* Mapping = UnSortedMappings[SortIndex].Mapping;
				Mappings.Add(Mapping);

				if (Mapping-&gt;bProcessMapping)
				{
					if (Mapping-&gt;Mesh)
					{
						Mapping-&gt;Mesh-&gt;Guid = FGuid(0,0,0,DeterministicIndex++);
					}
				}
			}
			UnSortedMappings.Empty();
		}

		// Verify deterministic lighting setup, if it is enabled...
		for (int32 CheckMapIdx = 0; CheckMapIdx &lt; Mappings.Num(); CheckMapIdx++)
		{
			if (Mappings[CheckMapIdx]-&gt;bProcessMapping)
			{
				FGuid CheckGuid = Mappings[CheckMapIdx]-&gt;Mesh-&gt;Guid;
				if ((CheckGuid.A != 0) ||
					(CheckGuid.B != 0) || 
					(CheckGuid.C != 0) ||
					(CheckGuid.D &gt;= (uint32)(Mappings.Num()))
					)
				{
					UE_LOG(LogStaticLightingSystem, Warning, TEXT("Lightmass: Error in deterministic lighting for %s:%s"),
						*(Mappings[CheckMapIdx]-&gt;Mesh-&gt;Guid.ToString()), *(Mappings[CheckMapIdx]-&gt;GetDescription()));
				}
			}
		}

		// if we are dumping binary results, clear up any existing ones
		if (Options.bDumpBinaryResults)
		{
			FStaticLightingSystem::ClearBinaryDumps();
		}
	}

	ProcessingStartTime = FPlatformTime::Seconds();

	bool bLightingSuccessful = false;
	if (!bForceNoPrecomputedLighting)
	{
		bool bSavedUpdateStatus_LightMap = FLightMap2D::GetStatusUpdate();
		if (GLightmassDebugOptions.bImmediateProcessMappings)
		{
			FLightMap2D::SetStatusUpdate(false);
		}

		bLightingSuccessful = CreateLightmassProcessor();
		if (bLightingSuccessful)
		{
			GatherScene();
			bLightingSuccessful = InitiateLightmassProcessor();
		}

		if (GLightmassDebugOptions.bImmediateProcessMappings)
		{
			FLightMap2D::SetStatusUpdate(bSavedUpdateStatus_LightMap);
		}
	}
	else
	{
		InvalidateStaticLighting();

		// Calling ApplyNewLightingData() results in creating an empty MapBuildData which is causing cooking issues
		// Disabled for now
		//ApplyNewLightingData(true);
	}
	
	if (!bForceNoPrecomputedLighting)
	{
		// End the static lighting progress bar.
		GWarn-&gt;EndSlowTask();
	}

	return bLightingSuccessful;
}

void FStaticLightingSystem::InvalidateStaticLighting()
{
	FLightmassStatistics::FScopedGather InvalidationScopeStat(LightmassStatistics.InvalidationTime);
	FGlobalComponentRecreateRenderStateContext Context;

	for( int32 LevelIndex=0; LevelIndex&lt;World-&gt;GetNumLevels(); LevelIndex++ )
	{
		bool bMarkLevelDirty = false;
		ULevel* Level = World-&gt;GetLevel(LevelIndex);
		
		if (!ShouldOperateOnLevel(Level))
		{
			continue;
		}

		const bool bBuildLightingForLevel = Options.ShouldBuildLightingForLevel( Level );
		
		if (bBuildLightingForLevel)
		{
			if (!Options.bOnlyBuildVisibility)
			{
				Level-&gt;ReleaseRenderingResources();

				if (Level-&gt;MapBuildData)
				{
					Level-&gt;MapBuildData-&gt;InvalidateStaticLighting(World, false, &amp;BuildDataResourcesToKeep);
				}
			}
			if (Level == World-&gt;PersistentLevel)
			{
				Level-&gt;PrecomputedVisibilityHandler.Invalidate(World-&gt;Scene);
				Level-&gt;PrecomputedVolumeDistanceField.Invalidate(World-&gt;Scene);
			}

			// Mark any existing cached lightmap data as transient. This allows the derived data cache to purge it more aggressively.
			// It is safe to do so even if some of these lightmaps are needed. It just means compressed data will have to be retrieved
			// from the network cache or rebuilt.
			if (GPurgeOldLightmaps != 0 &amp;&amp; Level-&gt;MapBuildData)
			{
				UPackage* MapDataPackage = Level-&gt;MapBuildData-&gt;GetOutermost();

				for (TObjectIterator&lt;ULightMapTexture2D&gt; It; It; ++It)
				{
					ULightMapTexture2D* LightMapTexture = *It;
					if (LightMapTexture-&gt;GetOutermost() == MapDataPackage)
					{
						LightMapTexture-&gt;MarkPlatformDataTransient();
					}
				}
			}
		}
	}
}

void UpdateStaticLightingHLODTreeIndices(TMultiMap&lt;AActor*, FStaticLightingMesh*&gt;&amp; ActorMeshMap, ALODActor* LODActor, uint32 HLODTreeIndex, uint32&amp; HLODLeafIndex)
{
	check(LODActor &amp;&amp; HLODTreeIndex &gt; 0);

	uint32 LeafStartIndex = HLODLeafIndex;
	++HLODLeafIndex;

	for (AActor* SubActor : LODActor-&gt;SubActors)
	{
		if (ALODActor* LODSubActor = Cast&lt;ALODActor&gt;(SubActor))
		{
			UpdateStaticLightingHLODTreeIndices(ActorMeshMap, LODSubActor, HLODTreeIndex, HLODLeafIndex);
		}
		else
		{
			TArray&lt;FStaticLightingMesh*&gt; SubActorMeshes;
			ActorMeshMap.MultiFind(SubActor,SubActorMeshes);

			for (FStaticLightingMesh* SubActorMesh : SubActorMeshes)
			{
				if (SubActorMesh-&gt;HLODTreeIndex == 0)
				{
					SubActorMesh-&gt;HLODTreeIndex = HLODTreeIndex;
					SubActorMesh-&gt;HLODChildStartIndex = HLODLeafIndex;
					SubActorMesh-&gt;HLODChildEndIndex = HLODLeafIndex;
					++HLODLeafIndex;
				}
				else
				{
					// Output error to message log containing tokens to the problematic objects
					FMessageLog("LightingResults").Warning()
						-&gt;AddToken(FUObjectToken::Create(SubActorMesh-&gt;Component-&gt;GetOwner()))
						-&gt;AddToken(FTextToken::Create(LOCTEXT("LightmassError_InvalidHLODTreeIndex", "will not be correctly lit since it is part of another Hierarchical LOD cluster besides ")))
						-&gt;AddToken(FUObjectToken::Create(LODActor));
				}
			}
		}
	}

	TArray&lt;FStaticLightingMesh*&gt; LODActorMeshes;
	ActorMeshMap.MultiFind(LODActor, LODActorMeshes);
	for (FStaticLightingMesh* LODActorMesh : LODActorMeshes)
	{
		LODActorMesh-&gt;HLODTreeIndex = HLODTreeIndex;
		LODActorMesh-&gt;HLODChildStartIndex = LeafStartIndex;
		LODActorMesh-&gt;HLODChildEndIndex = HLODLeafIndex - 1;
		check(LODActorMesh-&gt;HLODChildEndIndex &gt;= LODActorMesh-&gt;HLODChildStartIndex);
	}
}

void FStaticLightingSystem::GatherStaticLightingInfo(bool bRebuildDirtyGeometryForLighting, bool bForceNoPrecomputedLighting)
{
	uint32 ActorsInvalidated = 0;
	uint32 ActorsToInvalidate = 0;
	for( int32 LevelIndex=0; LevelIndex&lt;World-&gt;GetNumLevels(); LevelIndex++ )
	{
		ActorsToInvalidate += World-&gt;GetLevel(LevelIndex)-&gt;Actors.Num();
	}
	const int32 ProgressUpdateFrequency = FMath::Max&lt;int32&gt;(ActorsToInvalidate / 20, 1);

	GWarn-&gt;StatusUpdate( ActorsInvalidated, ActorsToInvalidate, LOCTEXT("GatheringSceneGeometryStatus", "Gathering scene geometry...") );
	
	bool bObjectsToBuildLightingForFound = false;
	// Gather static lighting info from actor components.
	for (int32 LevelIndex = 0; LevelIndex &lt; World-&gt;GetNumLevels(); LevelIndex++)
	{
		TSet&lt;UPackage*&gt; PackagesToDirty;

		ULevel* Level = World-&gt;GetLevel(LevelIndex);

		if (!ShouldOperateOnLevel(Level))
		{
			continue;
		}

		// If the geometry is dirty and we're allowed to automatically clean it up, do so
		if (Level-&gt;bGeometryDirtyForLighting)
		{
			UE_LOG(LogStaticLightingSystem, Warning, TEXT("WARNING: Lighting build detected that geometry needs to be rebuilt to avoid incorrect lighting (due to modifying a lighting property)."));
			if (bRebuildDirtyGeometryForLighting)
			{
				// This will go ahead and clean up lighting on all dirty levels (not just this one)
				UE_LOG(LogStaticLightingSystem, Warning, TEXT("WARNING: Lighting build automatically rebuilding geometry.") );
				GEditor-&gt;Exec(World, TEXT("MAP REBUILD ALLDIRTYFORLIGHTING"));
			}
		}

		const bool bBuildLightingForLevel = Options.ShouldBuildLightingForLevel(Level);

		// Gather static lighting info from BSP.
		bool bBuildBSPLighting = bBuildLightingForLevel;

		TArray&lt;FNodeGroup*&gt; NodeGroupsToBuild;
		TArray&lt;UModelComponent*&gt; SelectedModelComponents;
		if (bBuildBSPLighting &amp;&amp; !Options.bOnlyBuildVisibility)
		{
			if (Options.bOnlyBuildSelected)
			{
				UModel* Model = Level-&gt;Model;
				GLightmassDebugOptions.bGatherBSPSurfacesAcrossComponents = false;
				Model-&gt;GroupAllNodes(Level, Lights);
				bBuildBSPLighting = false;
				// Build only selected brushes/surfaces
				TArray&lt;ABrush*&gt; SelectedBrushes;
				for (int32 ActorIndex = 0; ActorIndex &lt; Level-&gt;Actors.Num(); ActorIndex++)
				{
					AActor* Actor = Level-&gt;Actors[ActorIndex];
					if (Actor)
					{
						ABrush* Brush = Cast&lt;ABrush&gt;(Actor);
						if (Brush &amp;&amp; Brush-&gt;IsSelected())
						{
							SelectedBrushes.Add(Brush);
						}
					}
				}

				TArray&lt;int32&gt; SelectedSurfaceIndices;
				// Find selected surfaces...
				for (int32 SurfIdx = 0; SurfIdx &lt; Model-&gt;Surfs.Num(); SurfIdx++)
				{
					bool bSurfaceSelected = false;
					FBspSurf&amp; Surf = Model-&gt;Surfs[SurfIdx];
					if ((Surf.PolyFlags &amp; PF_Selected) != 0)
					{
						SelectedSurfaceIndices.Add(SurfIdx);
						bSurfaceSelected = true;
					}
					else
					{
						int32 DummyIdx;
						if (SelectedBrushes.Find(Surf.Actor, DummyIdx) == true)
						{
							SelectedSurfaceIndices.Add(SurfIdx);
							bSurfaceSelected = true;
						}
					}

					if (bSurfaceSelected == true)
					{
						// Find it's model component...
						for (int32 NodeIdx = 0; NodeIdx &lt; Model-&gt;Nodes.Num(); NodeIdx++)
						{
							const FBspNode&amp; Node = Model-&gt;Nodes[NodeIdx];
							if (Node.iSurf == SurfIdx)
							{
								UModelComponent* SomeModelComponent = Level-&gt;ModelComponents[Node.ComponentIndex];
								if (SomeModelComponent)
								{
									SelectedModelComponents.AddUnique(SomeModelComponent);
									for (int32 InnerNodeIndex = 0; InnerNodeIndex &lt; SomeModelComponent-&gt;Nodes.Num(); InnerNodeIndex++)
									{
										FBspNode&amp; InnerNode = Model-&gt;Nodes[SomeModelComponent-&gt;Nodes[InnerNodeIndex]];
										SelectedSurfaceIndices.AddUnique(InnerNode.iSurf);
									}
								}
							}
						}
					}
				}

				// Pass 2...
				if (SelectedSurfaceIndices.Num() &gt; 0)
				{
					for (int32 SSIdx = 0; SSIdx &lt; SelectedSurfaceIndices.Num(); SSIdx++)
					{
						int32 SurfIdx = SelectedSurfaceIndices[SSIdx];
						// Find it's model component...
						for (int32 NodeIdx = 0; NodeIdx &lt; Model-&gt;Nodes.Num(); NodeIdx++)
						{
							const FBspNode&amp; Node = Model-&gt;Nodes[NodeIdx];
							if (Node.iSurf == SurfIdx)
							{
								UModelComponent* SomeModelComponent = Level-&gt;ModelComponents[Node.ComponentIndex];
								if (SomeModelComponent)
								{
									SelectedModelComponents.AddUnique(SomeModelComponent);
									for (int32 InnerNodeIndex = 0; InnerNodeIndex &lt; SomeModelComponent-&gt;Nodes.Num(); InnerNodeIndex++)
									{
										FBspNode&amp; InnerNode = Model-&gt;Nodes[SomeModelComponent-&gt;Nodes[InnerNodeIndex]];
										SelectedSurfaceIndices.AddUnique(InnerNode.iSurf);
									}
								}
							}
						}
					}
				}

				if (SelectedSurfaceIndices.Num() &gt; 0)
				{
					// Fill in a list of all the node group to rebuild...
					bBuildBSPLighting = false;
					for (TMap&lt;int32, FNodeGroup*&gt;::TIterator It(Model-&gt;NodeGroups); It; ++It)
					{
						FNodeGroup* NodeGroup = It.Value();
						if (NodeGroup &amp;&amp; (NodeGroup-&gt;Nodes.Num() &gt; 0))
						{
							for (int32 GroupNodeIdx = 0; GroupNodeIdx &lt; NodeGroup-&gt;Nodes.Num(); GroupNodeIdx++)
							{
								int32 CheckIdx;
								if (SelectedSurfaceIndices.Find(Model-&gt;Nodes[NodeGroup-&gt;Nodes[GroupNodeIdx]].iSurf, CheckIdx) == true)
								{
									NodeGroupsToBuild.AddUnique(NodeGroup);
									bBuildBSPLighting = true;
								}
							}
						}
					}
				}
			}
		}

		if (bBuildBSPLighting &amp;&amp; !bForceNoPrecomputedLighting)
		{
			if (!Options.bOnlyBuildSelected || Options.bOnlyBuildVisibility)
			{
				// generate BSP mappings across the whole level
				AddBSPStaticLightingInfo(Level, bBuildBSPLighting);
			}
			else
			{
				if (NodeGroupsToBuild.Num() &gt; 0)
				{
					bObjectsToBuildLightingForFound = true;
					AddBSPStaticLightingInfo(Level, NodeGroupsToBuild);
				}
			}
		}

		// Gather HLOD primitives
		TMultiMap&lt;AActor*, UPrimitiveComponent*&gt; PrimitiveActorMap;
		TMultiMap&lt;UPrimitiveComponent*, UStaticMeshComponent*&gt; PrimitiveSubStaticMeshMap;

		for (int32 ActorIndex = 0; ActorIndex &lt; Level-&gt;Actors.Num(); ActorIndex++)
		{
			AActor* Actor = Level-&gt;Actors[ActorIndex];
			if (Actor)
			{
				ALODActor* LODActor = Cast&lt;ALODActor&gt;(Actor);
				if (LODActor &amp;&amp; LODActor-&gt;GetStaticMeshComponent())
				{

					UPrimitiveComponent* PrimitiveParent = LODActor-&gt;GetStaticMeshComponent()-&gt;GetLODParentPrimitive();

					for (auto SubActor : LODActor-&gt;SubActors)
					{
						PrimitiveActorMap.Add(SubActor, LODActor-&gt;GetStaticMeshComponent());

						if (PrimitiveParent)
						{
							PrimitiveActorMap.Add(SubActor, PrimitiveParent);
						}

						TArray&lt;UStaticMeshComponent*&gt; SubStaticMeshComponents;
						SubActor-&gt;GetComponents(SubStaticMeshComponents);
						for (auto SMC : SubStaticMeshComponents)
						{
							PrimitiveSubStaticMeshMap.Add(LODActor-&gt;GetStaticMeshComponent(), SMC);
						}
					}
				}
			}
		}

		TMultiMap&lt;AActor*, FStaticLightingMesh*&gt; ActorMeshMap;
		TArray&lt;ALODActor*&gt; LODActors;

		// Gather static lighting info from actors.
		for (int32 ActorIndex = 0; ActorIndex &lt; Level-&gt;Actors.Num(); ActorIndex++)
		{
			AActor* Actor = Level-&gt;Actors[ActorIndex];
			if (Actor)
			{
				const bool bBuildActorLighting =
					bBuildLightingForLevel &amp;&amp;
					(!Options.bOnlyBuildSelected || Actor-&gt;IsSelected());

				TInlineComponentArray&lt;UPrimitiveComponent*&gt; Components;
				Actor-&gt;GetComponents(Components);

				if (bBuildActorLighting)
				{
					bObjectsToBuildLightingForFound = true;
				}

				TArray&lt;UPrimitiveComponent*&gt; HLODPrimitiveParents;
				PrimitiveActorMap.MultiFind(Actor, HLODPrimitiveParents);
				
				ALODActor* LODActor = Cast&lt;ALODActor&gt;(Actor);
				if (LODActor)
				{
					LODActors.Add(LODActor);
				}
				
				// Gather static lighting info from each of the actor's components.
				for (int32 ComponentIndex = 0; ComponentIndex &lt; Components.Num(); ComponentIndex++)
				{
					UPrimitiveComponent* Primitive = Components[ComponentIndex];
					if (Primitive-&gt;IsRegistered() &amp;&amp; !bForceNoPrecomputedLighting)
					{
						// Find the lights relevant to the primitive.
						TArray&lt;ULightComponent*&gt; PrimitiveRelevantLights;
						for (int32 LightIndex = 0; LightIndex &lt; Lights.Num(); LightIndex++)
						{
							ULightComponentBase* LightBase = Lights[LightIndex];
							ULightComponent* Light = Cast&lt;ULightComponent&gt;(LightBase);

							// Only add enabled lights
							if (Light &amp;&amp; Light-&gt;AffectsPrimitive(Primitive))
							{
								PrimitiveRelevantLights.Add(Light);
							}
						}

						// Query the component for its static lighting info.
						FStaticLightingPrimitiveInfo PrimitiveInfo;
						Primitive-&gt;GetStaticLightingInfo(PrimitiveInfo, PrimitiveRelevantLights, Options);
						if (PrimitiveInfo.Meshes.Num() &gt; 0 &amp;&amp; (Primitive-&gt;Mobility == EComponentMobility::Static))
						{
							if (World-&gt;GetWorldSettings()-&gt;bPrecomputeVisibility)
							{
								// Make sure packages gets dirtied since we are changing the visibility Id of a component in them
								PackagesToDirty.Add(Primitive-&gt;GetPackage());
							}

							PrimitiveInfo.VisibilityId = Primitive-&gt;VisibilityId = NextVisibilityId;
							NextVisibilityId++;
						}</pre><pre style="background:#ccffcc;">
						
						if (!CustomizePrimitiveInfo(Primitive, PrimitiveInfo)) continue; // Extensibility+</pre><pre>

						TArray&lt;UStaticMeshComponent*&gt; LODSubActorSMComponents;

						if (LODActor)
						{
							PrimitiveSubStaticMeshMap.MultiFind(Primitive, LODSubActorSMComponents);
						}

						for (auto Mesh : PrimitiveInfo.Meshes)
						{
							ActorMeshMap.Add(Actor, Mesh);
						}

						AddPrimitiveStaticLightingInfo(PrimitiveInfo, bBuildActorLighting);
					}
				}
			}

			ActorsInvalidated++;

			if (ActorsInvalidated % ProgressUpdateFrequency == 0)
			{
				GWarn-&gt;UpdateProgress(ActorsInvalidated, ActorsToInvalidate);
			}
		}

		// Recurse through HLOD trees, group actors and calculate child ranges
		uint32 HLODTreeIndex = 1;
		uint32 HLODLeafIndex;

		for (ALODActor* LODActor : LODActors)		
		{
			// Only process fully merged (root) HLOD nodes
			if (LODActor-&gt;GetStaticMeshComponent() &amp;&amp; !LODActor-&gt;GetStaticMeshComponent()-&gt;GetLODParentPrimitive())
			{
				HLODLeafIndex = 0;

				UpdateStaticLightingHLODTreeIndices(ActorMeshMap, LODActor, HLODTreeIndex, HLODLeafIndex);

				++HLODTreeIndex;
			}
		}

		// Mark package(s) as dirty
		for (UPackage* Package : PackagesToDirty)
		{
			Package-&gt;MarkPackageDirty();
		}
	}

	if (Options.bOnlyBuildSelected)
	{
		FMessageLog("LightingResults").Warning(LOCTEXT("LightmassError_BuildSelected", "Building selected actors only, lightmap memory and quality will be sub-optimal until the next full rebuild."));

		if (!bObjectsToBuildLightingForFound)
		{
			FMessageLog("LightingResults").Error(LOCTEXT("LightmassError_BuildSelectedNothingSelected", "Building selected actors and BSP only, but no actors or BSP selected!"));
		}
	}
}

void FStaticLightingSystem::EncodeTextures(bool bLightingSuccessful)
{
	FLightmassStatistics::FScopedGather EncodeStatScope(LightmassStatistics.EncodingTime);

	FScopedSlowTask SlowTask(2);
	{
		FLightmassStatistics::FScopedGather EncodeStatScope2(LightmassStatistics.EncodingLightmapsTime);
		// Flush pending shadow-map and light-map encoding.
		SlowTask.EnterProgressFrame(1, LOCTEXT("EncodingImportedStaticLightMapsStatusMessage", "Encoding imported static light maps."));
		FLightMap2D::EncodeTextures(World, LightingScenario, bLightingSuccessful, GMultithreadedLightmapEncode ? true : false);
	}

	{
		FLightmassStatistics::FScopedGather EncodeStatScope2(LightmassStatistics.EncodingShadowMapsTime);
		SlowTask.EnterProgressFrame(1, LOCTEXT("EncodingImportedStaticShadowMapsStatusMessage", "Encoding imported static shadow maps."));
		FShadowMap2D::EncodeTextures(World, LightingScenario, bLightingSuccessful, GMultithreadedShadowmapEncode ? true : false);
	}
}

void FStaticLightingSystem::ApplyNewLightingData(bool bLightingSuccessful)
{
	{
		FLightmassStatistics::FScopedGather ApplyStatScope(LightmassStatistics.ApplyTime);
		// Now that the lighting is done, we can tell the model components to use their new elements,
		// instead of the pre-lighting ones
		UModelComponent::ApplyTempElements(bLightingSuccessful);
	}

	{
		FLightmassStatistics::FScopedGather FinishStatScope(LightmassStatistics.FinishingTime);

		// Mark lights of the computed level to have valid precomputed lighting.
		for (int32 LevelIndex = 0; LevelIndex &lt; World-&gt;GetNumLevels(); LevelIndex++)
		{
			ULevel* Level = World-&gt;GetLevel(LevelIndex);

			if (!ShouldOperateOnLevel(Level))
			{
				continue;
			}

			ULevel* StorageLevel = LightingScenario ? LightingScenario : Level;
			UMapBuildDataRegistry* Registry = StorageLevel-&gt;GetOrCreateMapBuildData();
			
			// Notify level about new lighting data
			Level-&gt;OnApplyNewLightingData(bLightingSuccessful);

			if (World-&gt;PersistentLevel == Level)
			{
				Level-&gt;PrecomputedVisibilityHandler.UpdateScene(World-&gt;Scene);
				Level-&gt;PrecomputedVolumeDistanceField.UpdateScene(World-&gt;Scene);
			}

			uint32 ActorCount = Level-&gt;Actors.Num();

			for (uint32 ActorIndex = 0; ActorIndex &lt; ActorCount; ++ActorIndex)
			{
				AActor* Actor = Level-&gt;Actors[ActorIndex];

				if (Actor &amp;&amp; bLightingSuccessful &amp;&amp; !Options.bOnlyBuildSelected)
				{
					TInlineComponentArray&lt;ULightComponent*&gt; LightComponents;
					Actor-&gt;GetComponents(LightComponents);

					for (int32 ComponentIndex = 0; ComponentIndex &lt; LightComponents.Num(); ComponentIndex++)
					{
						ULightComponent* LightComponent = LightComponents[ComponentIndex];
						if (LightComponent &amp;&amp; (LightComponent-&gt;HasStaticShadowing() || LightComponent-&gt;HasStaticLighting()))
						{
							if (!Registry-&gt;GetLightBuildData(LightComponent-&gt;LightGuid))
							{
								// Add a dummy entry for ULightComponent::IsPrecomputedLightingValid()
								Registry-&gt;FindOrAllocateLightBuildData(LightComponent-&gt;LightGuid, true);
							}
						}
					}

					// For each SkyAtmosphere which is a dependency of the build, add its guid to MapBuildData to track that it now has been built.
					TInlineComponentArray&lt;USkyAtmosphereComponent*&gt; SkyAtmosphereComponents;
					Actor-&gt;GetComponents(SkyAtmosphereComponents);
					for (int32 ComponentIndex = 0; ComponentIndex &lt; SkyAtmosphereComponents.Num(); ComponentIndex++)
					{
						USkyAtmosphereComponent* SkyAtmosphereComponent = SkyAtmosphereComponents[ComponentIndex];
						if (SkyAtmosphereComponent)
						{
							if (!Registry-&gt;GetSkyAtmosphereBuildData(SkyAtmosphereComponent-&gt;GetStaticLightingBuiltGuid()))
							{
								Registry-&gt;FindOrAllocateSkyAtmosphereBuildData(SkyAtmosphereComponent-&gt;GetStaticLightingBuiltGuid());
							}
						}
					}
				}
			}

			const bool bBuildLightingForLevel = Options.ShouldBuildLightingForLevel( Level );

			// Store off the quality of the lighting for the level if lighting was successful and we build lighting for this level.
			if( bLightingSuccessful &amp;&amp; bBuildLightingForLevel )
			{
				Registry-&gt;LevelLightingQuality = Options.QualityLevel;
				Registry-&gt;MarkPackageDirty();
			}

			Registry-&gt;SetupLightmapResourceClusters();

			{
				int32 NumMeshes = 0;
				int32 NumClusters = 0;
				Registry-&gt;GetLightmapResourceClusterStats(NumMeshes, NumClusters);

				if (NumMeshes &gt; 1)
				{
					const float Ratio = (float)NumMeshes / (float)NumClusters;
					const FString StatsString = FString::Printf(TEXT("%s storing lightmap data for %u meshes in %u LightmapResourceClusters (%.1f Meshes per cluster)."),
						*Registry-&gt;GetName(), NumMeshes, NumClusters, Ratio);

					UE_LOG(LogStaticLightingSystem, Log, TEXT("%s"), *StatsString);
				}
			}

			Level-&gt;InitializeRenderingResources();
		}

		// Ensure all primitives which were marked dirty by the lighting build are updated.
		// First clear all components so that any references to static lighting assets held 
		// by scene proxies will be fully released before any components are reregistered.
		// We do not rerun construction scripts - nothing should have changed that requires that, and 
		// want to know which components were not moved during lighting rebuild
		{
			FGlobalComponentRecreateRenderStateContext RecreateRenderState;
		}

		// Clean up old shadow-map and light-map data.
		CollectGarbage( GARBAGE_COLLECTION_KEEPFLAGS );

		// Commit the changes to the world's BSP surfaces.
		World-&gt;CommitModelSurfaces();
	}

	// Report failed lighting build (don't count cancelled builds as failure).
	if ( !bLightingSuccessful &amp;&amp; !bBuildCanceled )
	{
		FMessageDialog::Open( EAppMsgType::Ok, LOCTEXT("LightingBuildFailedDialogMessage", "The lighting build failed! See the log for more information!") );
	}
}

/**
 * Reports lighting build statistics to the log.
 */
void FStaticLightingSystem::ReportStatistics()
{
	extern UNREALED_API bool GLightmassStatsMode;
	if ( GLightmassStatsMode )
	{
		double TrackedTime =
			LightmassStatistics.StartupTime
			+ LightmassStatistics.CollectTime
			+ LightmassStatistics.ProcessingTime
			+ LightmassStatistics.ImportTime
			+ LightmassStatistics.ApplyTime
			+ LightmassStatistics.EncodingTime
			+ LightmassStatistics.InvalidationTime
			+ LightmassStatistics.FinishingTime;
		double UntrackedTime = LightmassStatistics.TotalTime - TrackedTime;
		UE_LOG(LogStaticLightingSystem, Log,
			TEXT("Illumination: %s total\n")
			TEXT("   %3.1f%%\t%8.1fs    Untracked time\n")
			, *FPlatformTime::PrettyTime(LightmassStatistics.TotalTime)
			, UntrackedTime / LightmassStatistics.TotalTime * 100.0
			, UntrackedTime
		);
		UE_LOG(LogStaticLightingSystem, Log,
			TEXT("Breakdown of Illumination time\n")
			TEXT("   %3.1f%%\t%8.1fs \tStarting up\n")
			TEXT("   %3.1f%%\t%8.1fs \tCollecting\n")
			TEXT("   %3.1f%%\t%8.1fs \t--&gt; Preparing lights\n")
			TEXT("   %3.1f%%\t%8.1fs \t--&gt; Gathering lighting info\n")
			TEXT("   %3.1f%%\t%8.1fs \tProcessing\n")
			TEXT("   %3.1f%%\t%8.1fs \tImporting\n")
			TEXT("   %3.1f%%\t%8.1fs \tApplying\n")
			TEXT("   %3.1f%%\t%8.1fs \tEncoding\n")
			TEXT("   %3.1f%%\t%8.1fs \tInvalidating\n")
			TEXT("   %3.1f%%\t%8.1fs \tFinishing\n")
			, LightmassStatistics.StartupTime / LightmassStatistics.TotalTime * 100.0
			, LightmassStatistics.StartupTime
			, LightmassStatistics.CollectTime / LightmassStatistics.TotalTime * 100.0
			, LightmassStatistics.CollectTime
			, LightmassStatistics.PrepareLightsTime / LightmassStatistics.TotalTime * 100.0
			, LightmassStatistics.PrepareLightsTime
			, LightmassStatistics.GatherLightingInfoTime / LightmassStatistics.TotalTime * 100.0
			, LightmassStatistics.GatherLightingInfoTime
			, LightmassStatistics.ProcessingTime / LightmassStatistics.TotalTime * 100.0
			, LightmassStatistics.ProcessingTime
			, LightmassStatistics.ImportTime / LightmassStatistics.TotalTime * 100.0
			, LightmassStatistics.ImportTime
			, LightmassStatistics.ApplyTime / LightmassStatistics.TotalTime * 100.0
			, LightmassStatistics.ApplyTime
			, LightmassStatistics.EncodingTime / LightmassStatistics.TotalTime * 100.0
			, LightmassStatistics.EncodingTime
			, LightmassStatistics.InvalidationTime / LightmassStatistics.TotalTime * 100.0
			, LightmassStatistics.InvalidationTime
			, LightmassStatistics.FinishingTime / LightmassStatistics.TotalTime * 100.0
			, LightmassStatistics.FinishingTime
			);
		UE_LOG(LogStaticLightingSystem, Log,
			TEXT("Breakdown of Processing time\n")
			TEXT("   %3.1f%%\t%8.1fs \tCollecting Lightmass scene\n")
			TEXT("   %3.1f%%\t%8.1fs \tExporting\n")
			TEXT("   %3.1f%%\t%8.1fs \tLightmass\n")
			TEXT("   %3.1f%%\t%8.1fs \tSwarm startup\n")
			TEXT("   %3.1f%%\t%8.1fs \tSwarm callback\n")
			TEXT("   %3.1f%%\t%8.1fs \tSwarm job open\n")
			TEXT("   %3.1f%%\t%8.1fs \tSwarm job close\n")
			TEXT("   %3.1f%%\t%8.1fs \tImporting\n")
			TEXT("   %3.1f%%\t%8.1fs \tApplying\n")
			, LightmassStatistics.CollectLightmassSceneTime / LightmassStatistics.TotalTime * 100.0
			, LightmassStatistics.CollectLightmassSceneTime
			, LightmassStatistics.ExportTime / LightmassStatistics.TotalTime * 100.0
			, LightmassStatistics.ExportTime
			, LightmassStatistics.LightmassTime / LightmassStatistics.TotalTime * 100.0
			, LightmassStatistics.LightmassTime
			, LightmassStatistics.SwarmStartupTime / LightmassStatistics.TotalTime * 100.0
			, LightmassStatistics.SwarmStartupTime
			, LightmassStatistics.SwarmCallbackTime / LightmassStatistics.TotalTime * 100.0
			, LightmassStatistics.SwarmCallbackTime
			, LightmassStatistics.SwarmJobOpenTime / LightmassStatistics.TotalTime * 100.0
			, LightmassStatistics.SwarmJobOpenTime
			, LightmassStatistics.SwarmJobCloseTime / LightmassStatistics.TotalTime * 100.0
			, LightmassStatistics.SwarmJobCloseTime
			, LightmassStatistics.ImportTimeInProcessing / LightmassStatistics.TotalTime * 100.0
			, LightmassStatistics.ImportTimeInProcessing
			, LightmassStatistics.ApplyTimeInProcessing / LightmassStatistics.TotalTime * 100.0
			, LightmassStatistics.ApplyTimeInProcessing
		);

		UE_LOG(LogStaticLightingSystem, Log,
			TEXT("Breakdown of Export Times\n")
			TEXT("   %8.1fs\tVisibility Data\n")
			TEXT("   %8.1fs\tVolumetricLightmap Data\n")
			TEXT("   %8.1fs\tLights\n")
			TEXT("   %8.1fs\tModels\n")
			TEXT("   %8.1fs\tStatic Meshes\n")
			TEXT("   %8.1fs\tMaterials\n")
			TEXT("   %8.1fs\tMesh Instances\n")
			TEXT("   %8.1fs\tLandscape Instances\n")
			TEXT("   %8.1fs\tMappings\n")
			, LightmassStatistics.ExportVisibilityDataTime
			, LightmassStatistics.ExportVolumetricLightmapDataTime
			, LightmassStatistics.ExportLightsTime
			, LightmassStatistics.ExportModelsTime
			, LightmassStatistics.ExportStaticMeshesTime
			, LightmassStatistics.ExportMaterialsTime
			, LightmassStatistics.ExportMeshInstancesTime
			, LightmassStatistics.ExportLandscapeInstancesTime
			, LightmassStatistics.ExportMappingsTime
		);

		UE_LOG(LogStaticLightingSystem, Log,
			TEXT("Scratch counters\n")
			TEXT("   %3.1f%%\tScratch0\n")
			TEXT("   %3.1f%%\tScratch1\n")
			TEXT("   %3.1f%%\tScratch2\n")
			TEXT("   %3.1f%%\tScratch3\n")
			, LightmassStatistics.Scratch0
			, LightmassStatistics.Scratch1
			, LightmassStatistics.Scratch2
			, LightmassStatistics.Scratch3
		);

		float NumLightmapTotalTexels = float(FMath::Max&lt;uint64&gt;(GNumLightmapTotalTexels,1));
		float NumShadowmapTotalTexels = float(FMath::Max&lt;uint64&gt;(GNumShadowmapTotalTexels,1));
		float LightmapTexelsToMT = float(NUM_HQ_LIGHTMAP_COEF)/float(NUM_STORED_LIGHTMAP_COEF)/1024.0f/1024.0f;	// Strip out the SimpleLightMap
		float ShadowmapTexelsToMT = 1.0f/1024.0f/1024.0f;
		UE_LOG(LogStaticLightingSystem, Log, TEXT("Lightmap textures: %.1f M texels (%.1f%% mapped, %.1f%% unmapped, %.1f%% wasted by packing, %.1f M non-pow2 texels)")
			, NumLightmapTotalTexels * LightmapTexelsToMT
			, 100.0f * float(GNumLightmapMappedTexels) / NumLightmapTotalTexels
			, 100.0f * float(GNumLightmapUnmappedTexels) / NumLightmapTotalTexels
			, 100.0f * float(GNumLightmapTotalTexels - GNumLightmapMappedTexels - GNumLightmapUnmappedTexels) / NumLightmapTotalTexels
			, GNumLightmapTotalTexelsNonPow2 * LightmapTexelsToMT
			);

		UE_LOG(LogStaticLightingSystem, Log, TEXT("Shadowmap textures: %.1f M texels (%.1f%% mapped, %.1f%% unmapped, %.1f%% wasted by packing)")
			, NumShadowmapTotalTexels * ShadowmapTexelsToMT
			, 100.0f * float(GNumShadowmapMappedTexels) / NumShadowmapTotalTexels
			, 100.0f * float(GNumShadowmapUnmappedTexels) / NumShadowmapTotalTexels
			, 100.0f * float(GNumShadowmapTotalTexels - GNumShadowmapMappedTexels - GNumShadowmapUnmappedTexels) / NumShadowmapTotalTexels
			);

		for ( int32 LevelIndex=0; LevelIndex &lt; World-&gt;GetNumLevels(); LevelIndex++ )
		{
			ULevel* Level = World-&gt;GetLevel(LevelIndex);
			UE_LOG(LogStaticLightingSystem, Log,  TEXT("Level %2d - Lightmaps: %.1f MB. Shadowmaps: %.1f MB."), LevelIndex, Level-&gt;LightmapTotalSize/1024.0f, Level-&gt;ShadowmapTotalSize/1024.0f );
		}
	}
	else	//if ( GLightmassStatsMode)
	{
		UE_LOG(LogStaticLightingSystem, Log, TEXT("Illumination: %s (%s encoding lightmaps, %s encoding shadowmaps)"), *FPlatformTime::PrettyTime(LightmassStatistics.TotalTime), *FPlatformTime::PrettyTime(LightmassStatistics.EncodingLightmapsTime), *FPlatformTime::PrettyTime(LightmassStatistics.EncodingShadowMapsTime));
	}
	UE_LOG(LogStaticLightingSystem, Log, TEXT("Lightmap texture memory:  %.1f MB (%.1f MB streaming, %.1f MB non-streaming), %d textures"),
		GLightmapTotalSize/1024.0f/1024.0f,
		GLightmapTotalStreamingSize/1024.0f/1024.0f,
		(GLightmapTotalSize - GLightmapTotalStreamingSize)/1024.0f/1024.0f,
		GNumLightmapTextures);

	UE_LOG(LogStaticLightingSystem, Log, TEXT("Shadowmap texture memory: %.1f MB (%.1f MB streaming, %.1f MB non-streaming), %d textures"),
		GShadowmapTotalSize/1024.0f/1024.0f,
		GShadowmapTotalStreamingSize/1024.0f/1024.0f,
		(GShadowmapTotalSize - GShadowmapTotalStreamingSize)/1024.0f/1024.0f,
		GNumShadowmapTextures);
}

void FStaticLightingSystem::CompleteDeterministicMappings(class FLightmassProcessor* InLightmassProcessor)
{
	check(InLightmassProcessor != NULL);
	if (InLightmassProcessor &amp;&amp; GLightmassDebugOptions.bUseImmediateImport &amp;&amp; GLightmassDebugOptions.bImmediateProcessMappings)
	{
		// Already completed in the Lightmass Run function...
		return;
	}

	double ImportAndApplyStartTime = FPlatformTime::Seconds();
	double ApplyTime = 0.0;

	int32 CurrentStep = Mappings.Num();
	int32 TotalSteps = Mappings.Num() * 2;
	const int32 ProgressUpdateFrequency = FMath::Max&lt;int32&gt;(TotalSteps / 20, 1);
	GWarn-&gt;StatusUpdate( CurrentStep, TotalSteps, LOCTEXT("CompleteDeterministicMappingsStatusMessage", "Importing and applying deterministic mappings...") );

	// Process all the texture mappings first...
	for (int32 MappingIndex = 0; MappingIndex &lt; Mappings.Num(); MappingIndex++)
	{
		FStaticLightingTextureMapping* TextureMapping = Mappings[MappingIndex]-&gt;GetTextureMapping();
		if (TextureMapping)
		{
			//UE_LOG(LogStaticLightingSystem, Log, TEXT("%32s Completed - %s"), *(TextureMapping-&gt;GetDescription()), *(TextureMapping-&gt;GetLightingGuid().ToString()));

			if (!GLightmassDebugOptions.bUseImmediateImport)
			{
				InLightmassProcessor-&gt;ImportMapping(TextureMapping-&gt;GetLightingGuid(), true);
			}
			else
			{
				double ApplyStartTime = FPlatformTime::Seconds();
				InLightmassProcessor-&gt;ProcessMapping(TextureMapping-&gt;GetLightingGuid());
				ApplyTime += FPlatformTime::Seconds() - ApplyStartTime;
			}
		}

		CurrentStep++;

		if (CurrentStep % ProgressUpdateFrequency == 0)
		{
			GWarn-&gt;UpdateProgress(CurrentStep , TotalSteps);
		}
	}

	LightmassStatistics.ImportTimeInProcessing += FPlatformTime::Seconds() - ImportAndApplyStartTime - ApplyTime;
	LightmassStatistics.ApplyTimeInProcessing += ApplyTime;
}

struct FCompareByArrayCount
{
	FORCEINLINE bool operator()( const TArray&lt;ULightComponent*&gt;&amp; A, const TArray&lt;ULightComponent*&gt;&amp; B ) const 
	{ 
		// Sort by descending array count
		return B.Num() &lt; A.Num(); 
	}
};

/**
 * Generates mappings/meshes for all BSP in the given level
 *
 * @param Level Level to build BSP lighting info for
 * @param bBuildLightingForBSP If true, we need BSP mappings generated as well as the meshes
 */
void FStaticLightingSystem::AddBSPStaticLightingInfo(ULevel* Level, bool bBuildLightingForBSP)
{
	// For BSP, we aren't Component-centric, so we can't use the GetStaticLightingInfo 
	// function effectively. Instead, we look across all nodes in the Level's model and
	// generate NodeGroups - which are groups of nodes that are coplanar, adjacent, and 
	// have the same lightmap resolution (henceforth known as being "conodes"). Each 
	// NodeGroup will get a mapping created for it

	// cache the model
	UModel* Model = Level-&gt;Model;

	// reset the number of incomplete groups
	Model-&gt;NumIncompleteNodeGroups = 0;
	Model-&gt;CachedMappings.Empty();
	Model-&gt;bInvalidForStaticLighting = false;

	// create all NodeGroups
	Model-&gt;GroupAllNodes(Level, Lights);

	TSet&lt;UPackage*&gt; PackagesToDirty;

	// now we need to make the mappings/meshes
	for (TMap&lt;int32, FNodeGroup*&gt;::TIterator It(Model-&gt;NodeGroups); It; ++It)
	{
		FNodeGroup* NodeGroup = It.Value();

		if (NodeGroup-&gt;Nodes.Num() &amp;&amp; Level-&gt;ModelComponents.Num())
		{
			// get one of the surfaces/components from the NodeGroup
			// @todo: Remove need for GetSurfaceLightMapResolution to take a surfaceindex, or a ModelComponent :)
			UModelComponent* SomeModelComponent = Level-&gt;ModelComponents[Model-&gt;Nodes[NodeGroup-&gt;Nodes[0]].ComponentIndex];
			int32 SurfaceIndex = Model-&gt;Nodes[NodeGroup-&gt;Nodes[0]].iSurf;

			// fill out the NodeGroup/mapping, as UModelComponent::GetStaticLightingInfo did
			SomeModelComponent-&gt;GetSurfaceLightMapResolution(SurfaceIndex, true, NodeGroup-&gt;SizeX, NodeGroup-&gt;SizeY, NodeGroup-&gt;WorldToMap, &amp;NodeGroup-&gt;Nodes);

			// Make sure mapping will have valid size
			NodeGroup-&gt;SizeX = FMath::Max(NodeGroup-&gt;SizeX, 1);
			NodeGroup-&gt;SizeY = FMath::Max(NodeGroup-&gt;SizeY, 1);

			NodeGroup-&gt;MapToWorld = NodeGroup-&gt;WorldToMap.InverseFast();

			// Cache the surface's vertices and triangles.
			NodeGroup-&gt;BoundingBox.Init();

			TArray&lt;int32&gt; ComponentVisibilityIds;
			for(int32 NodeIndex = 0;NodeIndex &lt; NodeGroup-&gt;Nodes.Num();NodeIndex++)
			{
				const FBspNode&amp; Node = Model-&gt;Nodes[NodeGroup-&gt;Nodes[NodeIndex]];
				const FBspSurf&amp; NodeSurf = Model-&gt;Surfs[Node.iSurf];
				const FVector&amp; TextureBase = (FVector)Model-&gt;Points[NodeSurf.pBase];
				const FVector&amp; TextureX = (FVector)Model-&gt;Vectors[NodeSurf.vTextureU];
				const FVector&amp; TextureY = (FVector)Model-&gt;Vectors[NodeSurf.vTextureV];
				const int32 BaseVertexIndex = NodeGroup-&gt;Vertices.Num();
				// Compute the surface's tangent basis.
				FVector NodeTangentX = (FVector)Model-&gt;Vectors[NodeSurf.vTextureU].GetSafeNormal();
				FVector NodeTangentY = (FVector)Model-&gt;Vectors[NodeSurf.vTextureV].GetSafeNormal();
				FVector NodeTangentZ = (FVector)Model-&gt;Vectors[NodeSurf.vNormal].GetSafeNormal();

				// Generate the node's vertices.
				for(uint32 VertexIndex = 0;VertexIndex &lt; Node.NumVertices;VertexIndex++)
				{
					const FVert&amp; Vert = Model-&gt;Verts[Node.iVertPool + VertexIndex];
					const FVector&amp; VertexWorldPosition = (FVector)Model-&gt;Points[Vert.pVertex];

					FStaticLightingVertex* DestVertex = new(NodeGroup-&gt;Vertices) FStaticLightingVertex;
					DestVertex-&gt;WorldPosition = VertexWorldPosition;
					DestVertex-&gt;TextureCoordinates[0].X = ((VertexWorldPosition - TextureBase) | TextureX) / UModel::GetGlobalBSPTexelScale();
					DestVertex-&gt;TextureCoordinates[0].Y = ((VertexWorldPosition - TextureBase) | TextureY) / UModel::GetGlobalBSPTexelScale();
					DestVertex-&gt;TextureCoordinates[1].X = NodeGroup-&gt;WorldToMap.TransformPosition(VertexWorldPosition).X;
					DestVertex-&gt;TextureCoordinates[1].Y = NodeGroup-&gt;WorldToMap.TransformPosition(VertexWorldPosition).Y;
					DestVertex-&gt;WorldTangentX = NodeTangentX;
					DestVertex-&gt;WorldTangentY = NodeTangentY;
					DestVertex-&gt;WorldTangentZ = NodeTangentZ;

					// Include the vertex in the surface's bounding box.
					NodeGroup-&gt;BoundingBox += VertexWorldPosition;
				}

				// Generate the node's vertex indices.
				for(uint32 VertexIndex = 2;VertexIndex &lt; Node.NumVertices;VertexIndex++)
				{
					NodeGroup-&gt;TriangleVertexIndices.Add(BaseVertexIndex + 0);
					NodeGroup-&gt;TriangleVertexIndices.Add(BaseVertexIndex + VertexIndex);
					NodeGroup-&gt;TriangleVertexIndices.Add(BaseVertexIndex + VertexIndex - 1);

					// track the source surface for each triangle
					NodeGroup-&gt;TriangleSurfaceMap.Add(Node.iSurf);
				}

				UModelComponent* Component = Level-&gt;ModelComponents[Node.ComponentIndex];
				if (Component-&gt;VisibilityId == INDEX_NONE)
				{
					if (World-&gt;GetWorldSettings()-&gt;bPrecomputeVisibility)
					{
						// Make sure packages gets dirtied since we are changing the visibility Id of a component in them
						PackagesToDirty.Add(Component-&gt;GetPackage());
					}
					Component-&gt;VisibilityId = NextVisibilityId;
					NextVisibilityId++;
				}
				ComponentVisibilityIds.AddUnique(Component-&gt;VisibilityId);
			}

			// Continue only if the component accepts lights (all components in a node group have the same value)
			// TODO: If we expose CastShadow for BSP in the future, reenable this condition and make sure
			// node grouping logic is updated to account for CastShadow as well
			//if (SomeModelComponent-&gt;bAcceptsLights || SomeModelComponent-&gt;CastShadow)
			{
				// Create the object to represent the surface's mapping/mesh to the static lighting system,
				// the model is now the owner, and all nodes have the same 
				FBSPSurfaceStaticLighting* SurfaceStaticLighting = new FBSPSurfaceStaticLighting(NodeGroup, Model, SomeModelComponent);
				// Give the surface mapping the visibility Id's of all components that have nodes in it
				// This results in fairly ineffective precomputed visibility with BSP but is necessary since BSP mappings contain geometry from multiple components
				SurfaceStaticLighting-&gt;VisibilityIds = ComponentVisibilityIds;

				Meshes.Add(SurfaceStaticLighting);
				LightingMeshBounds += SurfaceStaticLighting-&gt;BoundingBox;

				if (SomeModelComponent-&gt;CastShadow)
				{
					UpdateAutomaticImportanceVolumeBounds( SurfaceStaticLighting-&gt;BoundingBox );
				}

				FStaticLightingMapping* CurrentMapping = SurfaceStaticLighting;
				if (GLightmassDebugOptions.bSortMappings)
				{
					int32 InsertIndex = UnSortedMappings.AddZeroed();
					FStaticLightingMappingSortHelper&amp; Helper = UnSortedMappings[InsertIndex];
					Helper.Mapping = CurrentMapping;
					Helper.NumTexels = CurrentMapping-&gt;GetTexelCount();
				}
				else
				{
					Mappings.Add(CurrentMapping);
					if (bBuildLightingForBSP)
					{
						CurrentMapping-&gt;Mesh-&gt;Guid = FGuid(0,0,0,DeterministicIndex++);
					}
				}

				if (bBuildLightingForBSP)
				{
					CurrentMapping-&gt;bProcessMapping = true;
				}

				// count how many node groups have yet to come back as complete
				Model-&gt;NumIncompleteNodeGroups++;

				// add this mapping to the list of mappings to be applied later
				Model-&gt;CachedMappings.Add(SurfaceStaticLighting);
			}
		}
	}

	// Mark package(s) as dirty
	for (UPackage* Package : PackagesToDirty)
	{
		Package-&gt;MarkPackageDirty();
	}
}

/**
 * Generates mappings/meshes for the given NodeGroups
 *
 * @param Level					Level to build BSP lighting info for
 * @param NodeGroupsToBuild		The node groups to build the BSP lighting info for
 */
void FStaticLightingSystem::AddBSPStaticLightingInfo(ULevel* Level, TArray&lt;FNodeGroup*&gt;&amp; NodeGroupsToBuild)
{
	// For BSP, we aren't Component-centric, so we can't use the GetStaticLightingInfo 
	// function effectively. Instead, we look across all nodes in the Level's model and
	// generate NodeGroups - which are groups of nodes that are coplanar, adjacent, and 
	// have the same lightmap resolution (henceforth known as being "conodes"). Each 
	// NodeGroup will get a mapping created for it

	// cache the model
	UModel* Model = Level-&gt;Model;

	// reset the number of incomplete groups
	Model-&gt;NumIncompleteNodeGroups = 0;
	Model-&gt;CachedMappings.Empty();
	Model-&gt;bInvalidForStaticLighting = false;

	// now we need to make the mappings/meshes
	for (int32 NodeGroupIdx = 0; NodeGroupIdx &lt; NodeGroupsToBuild.Num(); NodeGroupIdx++)
	{
		FNodeGroup* NodeGroup = NodeGroupsToBuild[NodeGroupIdx];
		if (NodeGroup &amp;&amp; NodeGroup-&gt;Nodes.Num())
		{
			// get one of the surfaces/components from the NodeGroup
			// @todo: Remove need for GetSurfaceLightMapResolution to take a surfaceindex, or a ModelComponent :)
			UModelComponent* SomeModelComponent = Level-&gt;ModelComponents[Model-&gt;Nodes[NodeGroup-&gt;Nodes[0]].ComponentIndex];
			int32 SurfaceIndex = Model-&gt;Nodes[NodeGroup-&gt;Nodes[0]].iSurf;

			// fill out the NodeGroup/mapping, as UModelComponent::GetStaticLightingInfo did
			SomeModelComponent-&gt;GetSurfaceLightMapResolution(SurfaceIndex, true, NodeGroup-&gt;SizeX, NodeGroup-&gt;SizeY, NodeGroup-&gt;WorldToMap, &amp;NodeGroup-&gt;Nodes);
			NodeGroup-&gt;MapToWorld = NodeGroup-&gt;WorldToMap.InverseFast();

			// Cache the surface's vertices and triangles.
			NodeGroup-&gt;BoundingBox.Init();

			for(int32 NodeIndex = 0;NodeIndex &lt; NodeGroup-&gt;Nodes.Num();NodeIndex++)
			{
				const FBspNode&amp; Node = Model-&gt;Nodes[NodeGroup-&gt;Nodes[NodeIndex]];
				const FBspSurf&amp; NodeSurf = Model-&gt;Surfs[Node.iSurf];
				const FVector&amp; TextureBase = (FVector)Model-&gt;Points[NodeSurf.pBase];
				const FVector&amp; TextureX = (FVector)Model-&gt;Vectors[NodeSurf.vTextureU];
				const FVector&amp; TextureY = (FVector)Model-&gt;Vectors[NodeSurf.vTextureV];
				const int32 BaseVertexIndex = NodeGroup-&gt;Vertices.Num();
				// Compute the surface's tangent basis.
				FVector NodeTangentX = (FVector)Model-&gt;Vectors[NodeSurf.vTextureU].GetSafeNormal();
				FVector NodeTangentY = (FVector)Model-&gt;Vectors[NodeSurf.vTextureV].GetSafeNormal();
				FVector NodeTangentZ = (FVector)Model-&gt;Vectors[NodeSurf.vNormal].GetSafeNormal();

				// Generate the node's vertices.
				for(uint32 VertexIndex = 0;VertexIndex &lt; Node.NumVertices;VertexIndex++)
				{
					const FVert&amp; Vert = Model-&gt;Verts[Node.iVertPool + VertexIndex];
					const FVector&amp; VertexWorldPosition = (FVector)Model-&gt;Points[Vert.pVertex];

					FStaticLightingVertex* DestVertex = new(NodeGroup-&gt;Vertices) FStaticLightingVertex;
					DestVertex-&gt;WorldPosition = VertexWorldPosition;
					DestVertex-&gt;TextureCoordinates[0].X = ((VertexWorldPosition - TextureBase) | TextureX) / UModel::GetGlobalBSPTexelScale();
					DestVertex-&gt;TextureCoordinates[0].Y = ((VertexWorldPosition - TextureBase) | TextureY) / UModel::GetGlobalBSPTexelScale();
					DestVertex-&gt;TextureCoordinates[1].X = NodeGroup-&gt;WorldToMap.TransformPosition(VertexWorldPosition).X;
					DestVertex-&gt;TextureCoordinates[1].Y = NodeGroup-&gt;WorldToMap.TransformPosition(VertexWorldPosition).Y;
					DestVertex-&gt;WorldTangentX = NodeTangentX;
					DestVertex-&gt;WorldTangentY = NodeTangentY;
					DestVertex-&gt;WorldTangentZ = NodeTangentZ;

					// Include the vertex in the surface's bounding box.
					NodeGroup-&gt;BoundingBox += VertexWorldPosition;
				}

				// Generate the node's vertex indices.
				for(uint32 VertexIndex = 2;VertexIndex &lt; Node.NumVertices;VertexIndex++)
				{
					NodeGroup-&gt;TriangleVertexIndices.Add(BaseVertexIndex + 0);
					NodeGroup-&gt;TriangleVertexIndices.Add(BaseVertexIndex + VertexIndex);
					NodeGroup-&gt;TriangleVertexIndices.Add(BaseVertexIndex + VertexIndex - 1);

					// track the source surface for each triangle
					NodeGroup-&gt;TriangleSurfaceMap.Add(Node.iSurf);
				}
			}

			// Continue only if the component accepts lights (all components in a node group have the same value)
			// TODO: If we expose CastShadow for BSP in the future, reenable this condition and make sure
			// node grouping logic is updated to account for CastShadow as well
			//if (SomeModelComponent-&gt;bAcceptsLights || SomeModelComponent-&gt;CastShadow)
			{
				// Create the object to represent the surface's mapping/mesh to the static lighting system,
				// the model is now the owner, and all nodes have the same 
				FBSPSurfaceStaticLighting* SurfaceStaticLighting = new FBSPSurfaceStaticLighting(NodeGroup, Model, SomeModelComponent);
				Meshes.Add(SurfaceStaticLighting);
				LightingMeshBounds += SurfaceStaticLighting-&gt;BoundingBox;

				if (SomeModelComponent-&gt;CastShadow)
				{
					UpdateAutomaticImportanceVolumeBounds( SurfaceStaticLighting-&gt;BoundingBox );
				}
				
				FStaticLightingMapping* CurrentMapping = SurfaceStaticLighting;
				if (GLightmassDebugOptions.bSortMappings)
				{
					int32 InsertIndex = UnSortedMappings.AddZeroed();
					FStaticLightingMappingSortHelper&amp; Helper = UnSortedMappings[InsertIndex];
					Helper.Mapping = CurrentMapping;
					Helper.NumTexels = CurrentMapping-&gt;GetTexelCount();
				}
				else
				{
					Mappings.Add(CurrentMapping);
					CurrentMapping-&gt;Mesh-&gt;Guid = FGuid(0,0,0,DeterministicIndex++);
				}

				CurrentMapping-&gt;bProcessMapping = true;

				// count how many node groups have yet to come back as complete
				Model-&gt;NumIncompleteNodeGroups++;

				// add this mapping to the list of mappings to be applied later
				Model-&gt;CachedMappings.Add(SurfaceStaticLighting);
			}
		}
	}
}

void FStaticLightingSystem::AddPrimitiveStaticLightingInfo(FStaticLightingPrimitiveInfo&amp; PrimitiveInfo, bool bBuildActorLighting)
{
	// Verify a one to one relationship between mappings and meshes
	//@todo - merge FStaticLightingMesh and FStaticLightingMapping
	check(PrimitiveInfo.Meshes.Num() == PrimitiveInfo.Mappings.Num());

	// Add the component's shadow casting meshes to the system.
	for(int32 MeshIndex = 0;MeshIndex &lt; PrimitiveInfo.Meshes.Num();MeshIndex++)
	{
		FStaticLightingMesh* Mesh = PrimitiveInfo.Meshes[MeshIndex];
		if (Mesh)
		{
			Mesh-&gt;VisibilityIds.Add(PrimitiveInfo.VisibilityId);
			if (!GLightmassDebugOptions.bSortMappings &amp;&amp; bBuildActorLighting)
			{
				Mesh-&gt;Guid = FGuid(0, 0, 0, DeterministicIndex++);
			}
			Meshes.Add(Mesh);
			LightingMeshBounds += Mesh-&gt;BoundingBox;

			if (Mesh-&gt;bCastShadow)
			{
				UpdateAutomaticImportanceVolumeBounds(Mesh-&gt;BoundingBox);
			}
		}
	}

	// If lighting is being built for this component, add its mappings to the system.
	for(int32 MappingIndex = 0;MappingIndex &lt; PrimitiveInfo.Mappings.Num();MappingIndex++)
	{
		FStaticLightingMapping* CurrentMapping = PrimitiveInfo.Mappings[MappingIndex];
		if (GbLogAddingMappings)
		{
			FStaticLightingMesh* SLMesh = CurrentMapping-&gt;Mesh;
			if (SLMesh)
			{
				//UE_LOG(LogStaticLightingSystem, Log, TEXT("Adding %32s: 0x%08p - %s"), *(CurrentMapping-&gt;GetDescription()), (PTRINT)(SLMesh-&gt;Component), *(SLMesh-&gt;Guid.ToString()));
			}
			else
			{
				//UE_LOG(LogStaticLightingSystem, Log, TEXT("Adding %32s: 0x%08x - %s"), *(CurrentMapping-&gt;GetDescription()), 0, TEXT("NO MESH????"));
			}
		}

		if (bBuildActorLighting)
		{
			CurrentMapping-&gt;bProcessMapping = true;
		}

		if (GLightmassDebugOptions.bSortMappings)
		{
			int32 InsertIndex = UnSortedMappings.AddZeroed();
			FStaticLightingMappingSortHelper&amp; Helper = UnSortedMappings[InsertIndex];
			Helper.Mapping = CurrentMapping;
			Helper.NumTexels = Helper.Mapping-&gt;GetTexelCount();
		}
		else
		{
			Mappings.Add(CurrentMapping);
		}
	}
}

bool FStaticLightingSystem::CreateLightmassProcessor()
{
	FLightmassStatistics::FScopedGather SwarmStartStatScope(LightmassProcessStatistics.SwarmStartupTime);
	
	GWarn-&gt;StatusForceUpdate( -1, -1, LOCTEXT("StartingSwarmConnectionStatus", "Starting up Swarm Connection...") );
	
	if (Options.bOnlyBuildVisibility &amp;&amp; !World-&gt;GetWorldSettings()-&gt;bPrecomputeVisibility)
	{
		FMessageDialog::Open( EAppMsgType::Ok, NSLOCTEXT("UnrealEd", "BuildFailed_VisibilityOnlyButVisibilityDisabled", "'Build Only Visibility' option was enabled but precomputed visibility is disabled!  Aborting build."));
		return false;
	}

	if (NSwarm::FSwarmInterface::Initialize(*(FPaths::EngineDir() / TEXT("Binaries/DotNET/SwarmInterface.dll"))) == false)
	{
		UE_LOG(LogStaticLightingSystem, Warning, TEXT("Failed to initialize Swarm."));
		FMessageDialog::Open(EAppMsgType::Ok,
#if USE_LOCAL_SWARM_INTERFACE
			LOCTEXT("FailedToInitializeSwarmDialogMessage_CheckNetwork", "Failed to initialize Swarm. Check to make sure you have the right version of Swarm installed.")
#else
			LOCTEXT("FailedToInitializeSwarmDialogMessage", "Failed to initialize Swarm. Check to make sure you have the right version of Swarm installed.")
#endif	
		);

		return false;
	}

	// Create the processor
	check(LightmassProcessor == NULL);
	LightmassProcessor = new FLightmassProcessor(*this, Options.bDumpBinaryResults, Options.bOnlyBuildVisibility);
	check(LightmassProcessor);
	if (LightmassProcessor-&gt;IsSwarmConnectionIsValid() == false)
	{
		UE_LOG(LogStaticLightingSystem, Warning, TEXT("Failed to connect to Swarm."));
		FMessageDialog::Open( EAppMsgType::Ok, 
#if USE_LOCAL_SWARM_INTERFACE
			LOCTEXT("FailedToConnectToSwarmDialogMessage_CheckNetwork", "Failed to connect to Swarm. Check that your network interface supports multicast.")
#else
			LOCTEXT("FailedToConnectToSwarmDialogMessage", "Failed to connect to Swarm.")
#endif	
		);
		delete LightmassProcessor;
		LightmassProcessor = NULL;
		return false;
	}

	return true;
}

void FStaticLightingSystem::GatherScene()
{
	LightmassProcessStatistics = FLightmassStatistics();

	GWarn-&gt;StatusUpdate( 0, Meshes.Num() + Mappings.Num(), LOCTEXT("GatherSceneStatusMessage", "Collecting the scene...") );
	
	FLightmassStatistics::FScopedGather SceneStatScope(LightmassProcessStatistics.CollectLightmassSceneTime);

	// Grab the exporter and fill in the meshes
	//@todo. This should be exported to the 'processor' as it will be used on the input side as well...
	FLightmassExporter* LightmassExporter = LightmassProcessor-&gt;GetLightmassExporter();
	check(LightmassExporter);

	// The Level settings...
	AWorldSettings* WorldSettings = World-&gt;GetWorldSettings();
	if (WorldSettings)
	{
		LightmassExporter-&gt;SetLevelSettings(WorldSettings-&gt;LightmassSettings);
	}
	else
	{
		FLightmassWorldInfoSettings TempSettings;
		LightmassExporter-&gt;SetLevelSettings(TempSettings);
	}
	LightmassExporter-&gt;SetNumUnusedLocalCores(Options.NumUnusedLocalCores);
	LightmassExporter-&gt;SetQualityLevel(Options.QualityLevel);

	if (World-&gt;PersistentLevel &amp;&amp; Options.ShouldBuildLightingForLevel( World-&gt;PersistentLevel ))
	{
		LightmassExporter-&gt;SetLevelName(World-&gt;PersistentLevel-&gt;GetPathName());
	}

	LightmassExporter-&gt;ClearImportanceVolumes();
	for( TObjectIterator&lt;ALightmassImportanceVolume&gt; It ; It ; ++It )
	{
		ALightmassImportanceVolume* LMIVolume = *It;
		if (World-&gt;ContainsActor(LMIVolume) &amp;&amp; IsValid(LMIVolume) &amp;&amp; ShouldOperateOnLevel(LMIVolume-&gt;GetLevel()))
		{
			LightmassExporter-&gt;AddImportanceVolume(LMIVolume);
		}
	}

	for( TObjectIterator&lt;ALightmassCharacterIndirectDetailVolume&gt; It ; It ; ++It )
	{
		ALightmassCharacterIndirectDetailVolume* LMDetailVolume = *It;
		if (World-&gt;ContainsActor(LMDetailVolume) &amp;&amp; IsValid(LMDetailVolume) &amp;&amp; ShouldOperateOnLevel(LMDetailVolume-&gt;GetLevel()))
		{
			LightmassExporter-&gt;AddCharacterIndirectDetailVolume(LMDetailVolume);
		}
	}

	for (TObjectIterator&lt;AVolumetricLightmapDensityVolume&gt; It; It; ++It)
	{
		AVolumetricLightmapDensityVolume* DetailVolume = *It;
		if (World-&gt;ContainsActor(DetailVolume) &amp;&amp; IsValid(DetailVolume) &amp;&amp; ShouldOperateOnLevel(DetailVolume-&gt;GetLevel()))
		{
			LightmassExporter-&gt;VolumetricLightmapDensityVolumes.Add(DetailVolume);
		}
	}

	for( TObjectIterator&lt;ULightmassPortalComponent&gt; It ; It ; ++It )
	{
		ULightmassPortalComponent* LMPortal = *It;
		if (LMPortal-&gt;GetOwner() &amp;&amp; World-&gt;ContainsActor(LMPortal-&gt;GetOwner()) &amp;&amp; IsValid(LMPortal) &amp;&amp; ShouldOperateOnLevel(LMPortal-&gt;GetOwner()-&gt;GetLevel()))
		{
			LightmassExporter-&gt;AddPortal(LMPortal);
		}
	}

	for (TObjectIterator&lt;USkyAtmosphereComponent&gt; It; It; ++It)
	{
		USkyAtmosphereComponent* SkyAtmosphere = *It;
		if (SkyAtmosphere-&gt;GetOwner() &amp;&amp; World-&gt;ContainsActor(SkyAtmosphere-&gt;GetOwner()) &amp;&amp; IsValid(SkyAtmosphere) &amp;&amp; ShouldOperateOnLevel(SkyAtmosphere-&gt;GetOwner()-&gt;GetLevel()))
		{
			LightmassExporter-&gt;SetSkyAtmosphereComponent(SkyAtmosphere);
			break;	// We only register the first we find
		}
	}

	float MinimumImportanceVolumeExtentWithoutWarning = 0.0f;
	verify(GConfig-&gt;GetFloat(TEXT("DevOptions.StaticLightingSceneConstants"), TEXT("MinimumImportanceVolumeExtentWithoutWarning"), MinimumImportanceVolumeExtentWithoutWarning, GLightmassIni));

	// If we have no importance volumes, then we'll synthesize one now.  A scene without any importance volumes will not yield
	// expected lighting results, so it's important to have a volume to pass to Lightmass.
	if (LightmassExporter-&gt;GetImportanceVolumes().Num() == 0)
	{
		FBox ReasonableSceneBounds = AutomaticImportanceVolumeBounds;
		if (ReasonableSceneBounds.GetExtent().SizeSquared() &gt; (MinimumImportanceVolumeExtentWithoutWarning * MinimumImportanceVolumeExtentWithoutWarning))
		{
			// Emit a serious warning to the user about performance.
			FMessageLog("LightingResults").PerformanceWarning(LOCTEXT("LightmassError_MissingImportanceVolume", "No importance volume found and the scene is so large that the automatically synthesized volume will not yield good results.  Please add a tightly bounding lightmass importance volume to optimize your scene's quality and lighting build times."));

			// Clamp the size of the importance volume we create to a reasonable size
			ReasonableSceneBounds = FBox(ReasonableSceneBounds.GetCenter() - MinimumImportanceVolumeExtentWithoutWarning, ReasonableSceneBounds.GetCenter() + MinimumImportanceVolumeExtentWithoutWarning);
		}
		else
		{
			// The scene isn't too big, so we'll use the scene's bounds as a synthetic importance volume
			// NOTE: We don't want to pop up a message log for this common case when creating a new level, so we just spray a log message.  It's not very important to a user.
			UE_LOG(LogStaticLightingSystem, Warning, TEXT("No importance volume found, so the scene bounding box was used.  You can optimize your scene's quality and lighting build times by adding importance volumes."));

			float AutomaticImportanceVolumeExpandBy = 0.0f;
			verify(GConfig-&gt;GetFloat(TEXT("DevOptions.StaticLightingSceneConstants"), TEXT("AutomaticImportanceVolumeExpandBy"), AutomaticImportanceVolumeExpandBy, GLightmassIni));

			// Expand the scene's bounds a bit to make sure volume lighting samples placed on surfaces are inside
			ReasonableSceneBounds = ReasonableSceneBounds.ExpandBy(AutomaticImportanceVolumeExpandBy);
		}

		LightmassExporter-&gt;AddImportanceVolumeBoundingBox(ReasonableSceneBounds);
	}

	const int32 NumMeshesAndMappings = Meshes.Num() + Mappings.Num();
	const int32 ProgressUpdateFrequency = FMath::Max&lt;int32&gt;(NumMeshesAndMappings / 20, 1);

	// Meshes
	for( int32 MeshIdx=0; !GEditor-&gt;GetMapBuildCancelled() &amp;&amp; MeshIdx &lt; Meshes.Num(); MeshIdx++ )
	{
		Meshes[MeshIdx]-&gt;ExportMeshInstance(LightmassExporter);

		if (MeshIdx % ProgressUpdateFrequency == 0)
		{
			GWarn-&gt;UpdateProgress( MeshIdx, NumMeshesAndMappings );
		}
	}

	// Mappings
	for( int32 MappingIdx=0; !GEditor-&gt;GetMapBuildCancelled() &amp;&amp; MappingIdx &lt; Mappings.Num(); MappingIdx++ )
	{
		Mappings[MappingIdx]-&gt;ExportMapping(LightmassExporter);

		if (MappingIdx % ProgressUpdateFrequency == 0)
		{
			GWarn-&gt;UpdateProgress( Meshes.Num() + MappingIdx, NumMeshesAndMappings );
		}
	}

	for (int32 LightIndex = 0; LightIndex &lt; Lights.Num(); LightIndex++)
	{
		ULightComponentBase* LightBase = Lights[LightIndex];
		USkyLightComponent* SkyLight = Cast&lt;USkyLightComponent&gt;(LightBase);

		if (SkyLight &amp;&amp; (SkyLight-&gt;Mobility == EComponentMobility::Static || SkyLight-&gt;Mobility == EComponentMobility::Stationary))
		{
			LightmassExporter-&gt;AddLight(SkyLight);
		}
	}
}
	
bool FStaticLightingSystem::InitiateLightmassProcessor()
{
	// Run!
	bool bSuccessful = false;
	bool bOpenJobSuccessful = false;
	if ( !GEditor-&gt;GetMapBuildCancelled() )
	{
		UE_LOG(LogStaticLightingSystem, Log, TEXT("Running Lightmass w/ ImmediateImport mode %s"), GLightmassDebugOptions.bUseImmediateImport ? TEXT("ENABLED") : TEXT("DISABLED"));
		LightmassProcessor-&gt;SetImportCompletedMappingsImmediately(GLightmassDebugOptions.bUseImmediateImport);
		UE_LOG(LogStaticLightingSystem, Log, TEXT("Running Lightmass w/ ImmediateProcess mode %s"), GLightmassDebugOptions.bImmediateProcessMappings ? TEXT("ENABLED") : TEXT("DISABLED"));
		UE_LOG(LogStaticLightingSystem, Log, TEXT("Running Lightmass w/ Sorting mode %s"), GLightmassDebugOptions.bSortMappings ? TEXT("ENABLED") : TEXT("DISABLED"));
		UE_LOG(LogStaticLightingSystem, Log, TEXT("Running Lightmass w/ Mapping paddings %s"), GLightmassDebugOptions.bPadMappings ? TEXT("ENABLED") : TEXT("DISABLED"));
		UE_LOG(LogStaticLightingSystem, Log, TEXT("Running Lightmass w/ Mapping debug paddings %s"), GLightmassDebugOptions.bDebugPaddings ? TEXT("ENABLED") : TEXT("DISABLED"));

		{
			FLightmassStatistics::FScopedGather OpenJobStatScope(LightmassProcessStatistics.SwarmJobOpenTime);
			bOpenJobSuccessful = LightmassProcessor-&gt;OpenJob();
		}

		if (bOpenJobSuccessful)
		{
			LightmassProcessor-&gt;InitiateExport();
			bSuccessful = true;
			CurrentBuildStage = FStaticLightingSystem::AmortizedExport;
		}
	}
	
	return bSuccessful;
}

void FStaticLightingSystem::KickoffSwarm()
{
	bool bSuccessful = LightmassProcessor-&gt;BeginRun();
	
	if (bSuccessful)
	{
		CurrentBuildStage = FStaticLightingSystem::AsynchronousBuilding;
	}
	else
	{
		FStaticLightingManager::Get()-&gt;FailLightingBuild(LOCTEXT("SwarmKickoffFailedMessage", "Lighting build failed. Swarm failed to kick off.  Compile Unreal Lightmass."));
	}
}

bool FStaticLightingSystem::FinishLightmassProcess()
{
	bool bSuccessful = false;

	GEditor-&gt;ResetTransaction( LOCTEXT("KeepLightingTransReset", "Applying Lighting") );

	CurrentBuildStage = FStaticLightingSystem::Import;

	double TimeWaitingOnUserToAccept = FPlatformTime::Seconds() - WaitForUserAcceptStartTime;
	
	{
		FScopedSlowTask SlowTask(7);
		SlowTask.MakeDialog();

		SlowTask.EnterProgressFrame(1, LOCTEXT("InvalidatingPreviousLightingStatus", "Invalidating previous lighting"));
		InvalidateStaticLighting();
	
		SlowTask.EnterProgressFrame(1, LOCTEXT("ImportingBuiltStaticLightingStatus", "Importing built static lighting"));
		bSuccessful = LightmassProcessor-&gt;CompleteRun();

		SlowTask.EnterProgressFrame();
		if (bSuccessful)
		{
			CompleteDeterministicMappings(LightmassProcessor);
		
			if (!Options.bOnlyBuildVisibility)
			{
				FLightmassStatistics::FScopedGather FinishStatScope(LightmassStatistics.FinishingTime);
				ULightComponent::ReassignStationaryLightChannels(GWorld, true, LightingScenario);
			}
		}
	

		SlowTask.EnterProgressFrame(1, LOCTEXT("EncodingTexturesStaticLightingStatis", "Encoding textures"));
		EncodeTextures(bSuccessful);


		SlowTask.EnterProgressFrame();
		{
			FLightmassStatistics::FScopedGather CloseJobStatScope(LightmassProcessStatistics.SwarmJobCloseTime);
			bSuccessful = LightmassProcessor-&gt;CloseJob() &amp;&amp; bSuccessful;
		}

		{
			FLightmassStatistics::FScopedGather FinishStatScope(LightmassStatistics.FinishingTime);
			// Add in the time measurements from the LightmassProcessor
			LightmassStatistics += LightmassProcessor-&gt;GetStatistics();

			// A final update on the lighting build warnings and errors dialog, now that everything is finished
			FMessageLog("LightingResults").Open();

			// Check the for build cancellation.
			bBuildCanceled = bBuildCanceled || GEditor-&gt;GetMapBuildCancelled();
			bSuccessful = bSuccessful &amp;&amp; !bBuildCanceled;

			FStatsViewerModule&amp; StatsViewerModule = FModuleManager::Get().LoadModuleChecked&lt;FStatsViewerModule&gt;(TEXT("StatsViewer"));
			if (bSuccessful)
			{
				StatsViewerModule.GetPage(EStatsPage::LightingBuildInfo)-&gt;Refresh();
			}
		
			bool bShowLightingBuildInfo = false;
			GConfig-&gt;GetBool( TEXT("LightingBuildOptions"), TEXT("ShowLightingBuildInfo"), bShowLightingBuildInfo, GEditorPerProjectIni );
			if( bShowLightingBuildInfo )
			{
				StatsViewerModule.GetPage(EStatsPage::LightingBuildInfo)-&gt;Show();
			}
		}

		SlowTask.EnterProgressFrame();
		ApplyNewLightingData(bSuccessful);

		SlowTask.EnterProgressFrame();

		// Finish up timing statistics
		LightmassStatistics += LightmassProcessStatistics;
		LightmassStatistics.TotalTime += FPlatformTime::Seconds() - StartTime - TimeWaitingOnUserToAccept;
	}

	ReportStatistics();
	
	return bSuccessful;
}

void FStaticLightingSystem::UpdateLightingBuild()
{
	if (CurrentBuildStage == FStaticLightingSystem::AmortizedExport)
	{
		bool bCompleted = LightmassProcessor-&gt;ExecuteAmortizedMaterialExport();

		FFormatNamedArguments Args;
		Args.Add( TEXT("PercentDone"), FText::AsPercent( LightmassProcessor-&gt;GetAmortizedExportPercentDone() ) );
		FText Text = FText::Format( LOCTEXT("LightExportProgressMessage", "Exporting lighting data: {PercentDone} Done"), Args );

		FStaticLightingManager::Get()-&gt;SetNotificationText( Text );

		if (bCompleted)
		{
			CurrentBuildStage = FStaticLightingSystem::SwarmKickoff;
		}
	}
	else if (CurrentBuildStage == FStaticLightingSystem::SwarmKickoff)
	{
		FText Text = LOCTEXT("LightKickoffSwarmMessage", "Kicking off Swarm");
		FStaticLightingManager::Get()-&gt;SetNotificationText( Text );
		KickoffSwarm();
	}
	else if (CurrentBuildStage == FStaticLightingSystem::AsynchronousBuilding)
	{
		bool bFinished = LightmassProcessor-&gt;Update();
		
		FString ScenarioString;

		if (LightingScenario)
		{
			FString PackageName = FPackageName::GetShortName(LightingScenario-&gt;GetOutermost()-&gt;GetName());
			ScenarioString = FString(TEXT(" for ")) + PackageName;
		}

		FText Text = FText::Format(LOCTEXT("LightBuildProgressMessage", "Building lighting{0}:  {1}%"), FText::FromString(ScenarioString), FText::AsNumber(LightmassProcessor-&gt;GetAsyncPercentDone()));
		FStaticLightingManager::Get()-&gt;SetNotificationText( Text );

		if (bFinished)
		{
			LightmassStatistics.ProcessingTime += FPlatformTime::Seconds() - ProcessingStartTime;
			WaitForUserAcceptStartTime = FPlatformTime::Seconds();

			FStaticLightingManager::Get()-&gt;ClearCurrentNotification();

			if (LightmassProcessor-&gt;IsProcessingCompletedSuccessfully())
			{
				CurrentBuildStage = FStaticLightingSystem::AutoApplyingImport;
			}
			else
			{
				// automatically fail lighting build (discard)
				FStaticLightingManager::Get()-&gt;FailLightingBuild();
				CurrentBuildStage = FStaticLightingSystem::Finished;
			}
		}
	}
	else if ( CurrentBuildStage == FStaticLightingSystem::AutoApplyingImport )
	{
		if (IsRunningCommandlet() || CanAutoApplyLighting())
		{
			bool bAutoApplyFailed = false;
			FStaticLightingManager::Get()-&gt;SendBuildDoneNotification(bAutoApplyFailed);

			FStaticLightingManager::ProcessLightingData();
			CurrentBuildStage = FStaticLightingSystem::Finished;
		}
		else
		{
			bool bAutoApplyFailed = true;
			FStaticLightingManager::Get()-&gt;SendBuildDoneNotification(bAutoApplyFailed);

			CurrentBuildStage = FStaticLightingSystem::WaitingForImport;
		}
	}
	else if (CurrentBuildStage == FStaticLightingSystem::ImportRequested)
	{
		FStaticLightingManager::ProcessLightingData();
		CurrentBuildStage = FStaticLightingSystem::Finished;
	}
}

void FStaticLightingSystem::UpdateAutomaticImportanceVolumeBounds( const FBox&amp; MeshBounds )
{
	// Note: skyboxes will be excluded if they are properly setup to not cast shadows
	AutomaticImportanceVolumeBounds += MeshBounds;
}

void FStaticLightingSystem::GatherBuildDataResourcesToKeep(const ULevel* InLevel)
{
	// This is only required is using a lighting scenario, otherwise the build data is saved within the level itself and follows it's inclusion in the lighting build.
	if (InLevel &amp;&amp; LightingScenario)
	{
		BuildDataResourcesToKeep.Add(InLevel-&gt;LevelBuildDataId);

		for (const UModelComponent * ModelComponent : InLevel-&gt;ModelComponents)
		{
			if (!ModelComponent) // Skip null models
			{
				continue;
			}
			ModelComponent-&gt;AddMapBuildDataGUIDs(BuildDataResourcesToKeep);
		}

		for (const AActor* Actor : InLevel-&gt;Actors)
		{
			if (!Actor) // Skip null actors
			{
				continue;
			}

			for (const UActorComponent* Component : Actor-&gt;GetComponents())
			{
				if (!Component) // Skip null components
				{
					continue;
				}

				const UPrimitiveComponent* PrimitiveComponent = Cast&lt;UPrimitiveComponent&gt;(Component);
				if (PrimitiveComponent)
				{
					PrimitiveComponent-&gt;AddMapBuildDataGUIDs(BuildDataResourcesToKeep);
					continue;
				}

				const ULightComponent* LightComponent = Cast&lt;ULightComponent&gt;(Component);
				if (LightComponent)
				{
					BuildDataResourcesToKeep.Add(LightComponent-&gt;LightGuid);
					continue;
				}

				const UReflectionCaptureComponent* ReflectionCaptureComponent = Cast&lt;UReflectionCaptureComponent&gt;(Component);
				if (ReflectionCaptureComponent)
				{
					BuildDataResourcesToKeep.Add(ReflectionCaptureComponent-&gt;MapBuildDataId);
					continue;
				}
			}
		}
	}
}


bool FStaticLightingSystem::CanAutoApplyLighting() const
{
	const bool bAutoApplyEnabled = GetDefault&lt;ULevelEditorMiscSettings&gt;()-&gt;bAutoApplyLightingEnable;
	const bool bSlowTask = GIsSlowTask;
	const bool bPlayWorldValid = GEditor-&gt;PlayWorld != nullptr;
	const bool bAnyMenusVisible = (FSlateApplication::IsInitialized() &amp;&amp; FSlateApplication::Get().AnyMenusVisible());
	//const bool bIsInteratcting = false;// FSlateApplication::Get().GetMouseCaptor().IsValid() || GEditor-&gt;IsUserInteracting();
	const bool bHasGameOrProjectLoaded = FApp::HasProjectName();

	return ( bAutoApplyEnabled &amp;&amp; !bSlowTask &amp;&amp; !bPlayWorldValid &amp;&amp; !bAnyMenusVisible/* &amp;&amp; !bIsInteratcting */&amp;&amp; !GIsDemoMode &amp;&amp; bHasGameOrProjectLoaded );
}

/**
 * Clear out all the binary dump log files, so the next run will have just the needed files for rendering
 */
void FStaticLightingSystem::ClearBinaryDumps()
{
	IFileManager::Get().DeleteDirectory(*FString::Printf(TEXT("%sLogs/Lighting_%s"), *FPaths::ProjectDir(), TEXT("Lightmass")), false, true);
}

/** Marks all lights used in the calculated lightmap as used in a lightmap, and calls Apply on the texture mapping. */
void FStaticLightingSystem::ApplyMapping(
	FStaticLightingTextureMapping* TextureMapping,
	FQuantizedLightmapData* QuantizedData,
	const TMap&lt;ULightComponent*,FShadowMapData2D*&gt;&amp; ShadowMapData) const
{
	TextureMapping-&gt;Apply(QuantizedData, ShadowMapData, LightingScenario);
}

UWorld* FStaticLightingSystem::GetWorld() const
{
	return World;
}

bool FStaticLightingSystem::IsAsyncBuilding() const
{
	return CurrentBuildStage == FStaticLightingSystem::AsynchronousBuilding;
}

bool FStaticLightingSystem::IsAmortizedExporting() const
{
	return CurrentBuildStage == FStaticLightingSystem::AmortizedExport;
}

void UEditorEngine::BuildLighting(const FLightingBuildOptions&amp; Options)
{
	// Forcibly shut down all texture property windows as they become invalid during a light build
	UAssetEditorSubsystem* AssetEditorSubsystem = GEditor-&gt;GetEditorSubsystem&lt;UAssetEditorSubsystem&gt;();
	TArray&lt;UObject*&gt; EditedAssets = AssetEditorSubsystem-&gt;GetAllEditedAssets();

	for (int32 AssetIdx = 0; AssetIdx &lt; EditedAssets.Num(); AssetIdx++)
	{
		UObject* EditedAsset = EditedAssets[AssetIdx];

		if (EditedAsset-&gt;IsA(UTexture2D::StaticClass()))
		{
			IAssetEditorInstance* Editor = AssetEditorSubsystem-&gt;FindEditorForAsset(EditedAsset, false);
			if (Editor)
			{
				Editor-&gt;CloseWindow(EAssetEditorCloseReason::AssetUnloadingOrInvalid);
			}
		}
	}
	
	FEditorDelegates::OnLightingBuildStarted.Broadcast();

	FStaticLightingManager::Get()-&gt;CreateStaticLightingSystem(Options);
}

void UEditorEngine::UpdateBuildLighting()
{
	FStaticLightingManager::Get()-&gt;UpdateBuildLighting();

	FStaticLightingSystemInterface::EditorTick();
}

bool UEditorEngine::IsLightingBuildCurrentlyRunning() const
{
	return FStaticLightingManager::Get()-&gt;IsLightingBuildCurrentlyRunning();
}

bool UEditorEngine::IsLightingBuildCurrentlyExporting() const
{
	return FStaticLightingManager::Get()-&gt;IsLightingBuildCurrentlyExporting(); 
}

bool UEditorEngine::WarnIfLightingBuildIsCurrentlyRunning()
{
	bool bFailure = IsLightingBuildCurrentlyRunning();
	if (bFailure)
	{
		FNotificationInfo Info( LOCTEXT("LightBuildUnderwayWarning", "Static light is currently building! Please cancel it to proceed!") );
		Info.ExpireDuration = 5.0f;
		TSharedPtr&lt;SNotificationItem&gt; Notification = FSlateNotificationManager::Get().AddNotification(Info);
		if (Notification.IsValid())
		{
			Notification-&gt;SetCompletionState(SNotificationItem::CS_Fail);
		}
	}
	else if (FEditorBuildUtils::IsBuildCurrentlyRunning())
	{
		// Another, non-lighting editor build is running.
		FNotificationInfo Info( LOCTEXT("EditorBuildUnderwayWarning", "A build process is currently underway! Please cancel it to proceed!") );
		Info.ExpireDuration = 5.0f;
		TSharedPtr&lt;SNotificationItem&gt; Notification = FSlateNotificationManager::Get().AddNotification(Info);
		if (Notification.IsValid())
		{
			Notification-&gt;SetCompletionState(SNotificationItem::CS_Fail);
		}

		bFailure = true;
	}
	return bFailure;
}

#undef LOCTEXT_NAMESPACE
</pre>